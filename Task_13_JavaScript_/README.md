**Người thực hiện: Hoả Ngọc Lê Hùng** 

**AT13M**

**Task 13:** 

# [Mục lục:](#1212)

# [A. Nội dung](#a)

[1.Hello, world!](#1)

[2.Code structure](#2)

[3.The modern mode, "use strict"](#3)

[4.Variables](#4)
**Người thực hiện: Hoả Ngọc Lê Hùng** 

**AT13M**

**Task 13:** 

# [Mục lục:](#1212)

# [A. Nội dung](#a)

[1.Hello, world!](#1)

[2.Code structure](#2)

[3.The modern mode, "use strict"](#3)

[4.Variables](#4)

[5.Data types](#5)

[6.Type Conversions](#6)

[7.Operators](#7)

[8.Comparisons](#8)

[9.Interaction: alert, prompt, confirm](#9)

[10.Conditional operators: if, '?'](#10)

[11.Logical operators](#11)

[12.Loops: while and for](#12)

[13.The "switch" statement](#13)

[14.Functions](#14)

[15.Function expressions and arrows](#15)

[16.JavaScript specials](#16)

# B. [Tổng kết.](#b)

>----------

<a name="a"></a>
# A. Nội dung.

<a name="1"></a>
# 1. Hello, world!

## The "script" tag.

Chương tronhf JavaScript có thể được chèn vào bất kỳ vị trí nào của HTML với sự trợ giúp của thẻ `<script>`.

Ví dụ:

```
<!DOCTYPE HTML>
<html>

<body>

  <p>hùng lê</p>

  <script>
    alert( 'Hello, hùng lê!' );
  </script>

  <p>...See you again.</p>

</body>

</html>

```

Thẻ `<script>` chứa mã JavaScript được tự động thực hiện khi trình duyệt gặp thẻ.

## The modern markup.

Thẻ `<script>` có vài thuộc tính hiếm khi được sử dụng hiện nạy, nhưng chúng ta có thể tìm thấy chúng trong mã cũ:

Thuộc tính type : `<script type=...>`

Tiêu chuẩn cũ HTML4 yêu cầu một tập lệnh để có một loại. Thông thường đó là type = "text/javascript". Chuẩn HTML hiện đại giả định kiểu này theo mặc định, không có thuộc tính nào được yêu cầu.

Thuộc tính language: `<script language=...>`.

Thuộc tính này có nghĩa là hiển thị ngôn ngữ của script. Tính đến thời điểm hiện tại, thuộc tính này không còn ý nghĩa, ngôn ngữ mặc định là ngôn ngữ JavaScript. Không cần sử dụng nó.

### Bình luận trước và sau script.

Trong sách hướng dẫn người ta có thể tìm thấy nhận xét bên trong `<script>` như sau:

```
<script type="text/javascript"><!--
    ...
//--></script>

```


## Bên ngoài script.

Nếu chúng ta có rất nhiều mà JavaScript, chúng ta có thể đặt nó vào một file riêng biệt.

Script được đính kèm với HTML với thuộc tính `src`:

`<script src="/path/to/script.js"></script> `

Ở đây là đường dẫn tuyệt đối đến tập tin với tập lệnh (từ gốc trang web). Cũng có thể cung cấp một đường dẫn liên quan đến trang web hiện tại. Ví dụ: `src="script.js"` sẽ có nghĩa là một tệp "script.js" từ thư mục hiện tại.

Chúng ta cũng có thể đua ra một URL đầy đủ:

`<script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/3.2.0/lodash.js"></script>`

Đính kèm một số tập lệnh, sử dụng nhiều thẻ: 

```
<script src="/js/script1.js"></script>
<script src="/js/script2.js"></script>
…
```

**Lưu ý**

Theo nguyên tắc, chỉ có các tập lệnh đơn giản nhất được đưa vào HTML. Những tệp tin phức tạp hơn nằm trong các tệp riêng biệt.

Lợi ích của một tập tin riêng biệt là trình duyệt sẽ tải nó và sau đó lưu trữ trong bộ nhớ cache của nó.

Sau đó, các trang khác muốn có cùng một tập lệnh sẽ lấy từ bộ nhớ cache thay vì tải nó. Vì vậy, các tập tin thực sự chỉ tải về một lần.

Điều đó giúp tiết kiệm lưu lượng truy cập và làm cho các trang nhanh hơn.

**Nếu src được thiết lập, nội dung script sẽ bỏ bỏ qua.**

Thẻ `<script>` duy nhất có thể không có thuộc tính src và mã bên trong.

```
<script src="file.js">
  alert(1); // nội dung bị bỏ qua vì src đã được đặt.
</script>
```

Chúng ta phải lựa chọn một là bên ngoài `<script src="...">` hoặc `<script>` với code.

Ví dụ trên có thể chia hai phần script để hoạt động:

```
<script src="file.js"></script>
<script>
  alert(1);
</script>
```

## Summary (tóm lược).


Chúng ta có thể sử dụng thẻ script để thêm mã JavaScript vào trang.

Không yêu cầu thuộc tính type là language.

Một script trong một tập tin bên ngoài có thể được chèn với `<script src = "path / to / script.js"> </ script>.`

Có rất nhiều trình duyệt script và sự tương tác của họ với trang web. Nhưng chúng ta hãy nhớ rằng phần này của hướng dẫn này cho ngôn ngữ JavaScript, vì vậy chúng ta không nên sao lãng chính nó. Chúng tôi sẽ sử sử dụng trình duyệt như một cách để chạy Javascript, rất tiện lợi cho việc đọc trực tuyến, nhưng vẫn là một trong nhiều.

## Bài tập


### Hiển thị cảnh báo.
Create a page that shows a message “I’m JavaScript!”.

```
<!DOCTYPE html>
<html>
<head>
    <title>huyen tran</title>
</head>
<body>

<b>hung le</b>

<script> alert('I’m JavaScript!'); </script>

</body>
</html>

```

### Hiển thị cảnh báo với một tệp bên ngoài


```
<!DOCTYPE html>
<html>
<head>
    <title>huyen tran</title>
</head>
<body>

<b>hung le</b>
<script src="qưe.js"></script>
<script> alert('I’m JavaScript!'); </script>

</body>
</html>
```

**JS**

```
let str = "Hello";
let str2 = 'Single quotes are ok too';
let phrase = `can embed ${str}`;
alert(phrase);
```


<a name="2"></a>
# 2. Code structure

Đầu tiên cần nghiên cứu là các khối xây dựng mã.

## Statements

Các câu lệnh là cấu trúc cú pháp và các lệnh thực hiện các hành động.

Chúng tôi đã nhìn thấy thông báo cảnh báo ('hello, world!'), với hiển thị thông báo.

Chúng ta có thể có nhiều câu lệnh trong mã như chúng ta muốn. Một tuyên bố có thể được tách ra bằng một dấu chấm phẩy.

Ví dụ ở đây chúng tôi chia thành hai thông điệp: 

`alert('Hello'); alert('World');`

Thông thường mỗi câu lệnh được viết trên một dòng riêng biệt - do đó mã trở nên dễ đọc hơn:

```
alert('Hello');
alert('World');
```

## Semicolons (dấu chấm phẩy)

Một dấu chấm phẩy có thể được bỏ qua trong hầu hết các trường hợp khi ngắt dòng tồn tại.

Điều này cũng sẽ làm việc: 

```
alert('Hello')
alert('World')
```

Ở đây JavaScript giải nghĩa ngắt dòng như là một dấu chấm phẩy "ẩn". Đó cũng được gọi là chèn dấu chấm phẩy tự động.

**Trong hầu hết các trường hợp một dòng mới bao hàm một dáu chấm phẩy. Nhưng "trong hầu hết các trường hợp" không có nghĩa là "luôn luôn".!**

Có những trường hợp khi một dòng mới không có nghĩa là một dấu chấm phẩy, ví dụ:

```
alert(3 +
1
+ 2); //result 6
```

Mã đầu ra 6, vì JavaScript không chèn dấu phẩy ở đây. Rõ ràng là nếu dòng kết thúc bằng một dấu cộng "+" thì đó là một biểu hiện không đầy đủ, không cần dấu chấm phẩy. Và trong trường hợp này hoạt động như dự định.

**Nhưng có những tình huống mà JavaScript không thành công để giả sử một dấu chấm phẩy nơi nó thực sự cần thiết.**

Lỗi trong các tình huống như vậy là khá khó để tìm và sữa chữa.

Ví dụ:

```
alert("There will be an error")  //thiếu dấu chấm phẩy.

[1, 2].forEach(alert)
```

Ở đây thiếu một dấu chấm phẩy mà nó sẽ bị lỗi

Nếu thêm dấu chấm phẩy thì mọi chuyện bình thường:

```
alert("All fine now");

[1, 2].forEach(alert)
```

Lỗi trong biến thể không có dấu chấm phẩy xãy ra vì JavaScript không ngụ ý một dấu chấm phẩy trước ngoặc vuông [...].

Vì vậy, bời vì chèn dấu chấm phẩy được tự động chèn vào, mã trong ví dụ đầu tiên được coi là một câu lệnh, đó là cách mà một công cụ nhìn thấy nó:

`alert("There will be an error")[1, 2].forEach(alert)`

Nhưng không cần phải có hai tuyên bố riêng biệt, không phỉa là một báo cáo riêng lẽ. Việc hợp nhất trong trường hợp này chỉ là sai, vì thế là lỗi. Có những tình huống khác khi điều đó sãy ra.

Bạn nên đặt dấy chấm phẩy giữa các câu lệnh ngay khi chúng được phân cách bằng một dòng mới. Quy tắc này được cộng đồng chấp nhận rộng rãi. Chúng ta hãy lưu ý một lần nữa- có thể bỏ dấu chấm phẩy bất kể thời gian. Nhưng nó an toàn hơn, đặc biệt là cho người bắt đầu- để đặt chúng.

## Comments

Thời gian trôi đi, chương trinh ngày càng phức tạp. Nó sẽ trở thành cần thiết để thêm ý kiến mô tả những gì xãy ra và tại sao. Nhận xét có thể được đưa vào bất kì nơi nào của kịch bản. Họ không ảnh hưởng đến việc thực hiện, bởi vì động cơ chỉ cần bỏ qua chúng.

**Một dòng nhận xét bắt đầu với hai dấu gạch chéo phía trước "//"**

Ví dụ:

```
// This comment occupies a line of its own
alert('Hello');

alert('World'); // This comment follows the statement
```

**Nhận xet nhiều dòng**

```
/* An example with two messages.
This is a multiline comment.
*/
alert('Hello');
alert('World');
```

**Không được để nhận xét lồng vào nhau!!!**

<a name="3"></a>
# 3.The modern mode, "use strict".

Trong một thời gian dài JavaScript đã được phát triển mà không có vấn đề tương thích. Các tính năng mới đã được thêm vào ngôn ngữ, nhưng chức năng cũ không thay đổi.

Điều đó có lợi ích không bao giờ phá vỡ các mã hiện có. Nhưng nhược điểm là bất kỳ sai lầm hoặc một quyết định không hoàn hảo của người sáng tạo đã bị măc kẹt trong ngôn ngữ mãi mãi.

Nó đã được cho đến năm 2009 khi SCMAScript 5 (ES5) xuất hiện. Nó bổ xung các tính năng mới cho ngôn ngữ và sữa đổi một số các tính năng hiện có. Để giữ mã cũ hoạt động, hầu hết các sữa đổi đề bị tắt theo mặc định. Người ta cần phải cho phép họ rõ ràng với một chỉ thị đặc biệt "use strict".

**use strict**

Chỉ thị giống như một chuỗi: "use strict" hoặc 'use strict'. Khi nó nằm trên đỉnh của kịch bản, sau đó toàn bộ kịch bản hoạt động theo cách hiện đại.

Ví dụ:

```
"use strict";

// mã này hoạt động theo cách hiện đại.
...

```

Nhìn về phía trước chúng ta chỉ cần lưu ý rằng "use strict" cỏ thể đặt ở đầu của một số chức năng (hầu hết các loại chức năng) thay vì toàn bộ kịch bản. Sau đó chế độ nghiêm ngặt được bật trong chức năng đó. Nhưng thường mọi người sử dụng nó cho toàn bộ stript.

**Đảm bảo rằng use strict là ở đầu.**

Hãy đảm bảo rằng "use strict" là ở đầu, nếu không chế độ nghiêm ngặt có thể không được kích hoạt.

Không có "use strict" ở đây:

```
alert("some code");
// "use strict" ở đây bị bỏ qua, phải đặt trên đầu trang.

"use strict";

// strict mode không được kích hoạt
```

Chỉ có nhận xét xuất hiện ở trên "use strict".

**Không có cách nào để huỷ bỏ use strict**.

Không có chỉ thị "no use strict" hoặc giống nhau, mà có thể trở lại hành vi cũ.

Một khi vào use strict, không có trở lại.

## Always "use strict" (luôn sử dụng use strict)

Sự khác biệt của chế độ "use strict" so với chế độ mặc định vẫn dduojcwj bảo vệ.

Trong thời điểm hiện tại, nó đủ để biết vế nó nói chung:
1. Use strict sẽ chuyển công cụ sang chế độ "modern", thay đổi hành vi của một số tính năng được tích hợp.
2. Chế độ strict  được kích hoạt bởi "use strict" ở trên cùng. Ngoài ra có một số tính năng ngôn ngữ như "classes" và "modules" cho phép chế độ strict tự động.
3. Chế độ strict được hỗ trợ bởi tất cả các trình duyệt hiện đại.
4. Luôn luôn đề nghị bắt đầu các tập lệnh với "use strict". Tất cả các ví dụ trong hướng dẫn này giả sử như vậy, trừ khi quy định khác.

<a name="4"></a>
# 4.Variables.

Hầu hết thời gian, một kịch bản cần làm việc với thông tin. Nếu đó là một của hàng trực tuyến - đó sẽ là hàng hoá và giỏ hàng. Nếu đó là cuộc trò chuyện- người dùng, tin nhắn....

Các biến được sử dụng để lưu trữ thông tin.

## A variable

Một biến là một "name storage" cho dữ liệu. Chúng ta có thể sử dụng các biến để lưu trữ goodies, thăm và các dữ liệu khác. 

Để tạo một biến Javascript, chúng ta cần sử dụng từ khoá `let`.

Ví dụ: `let message;`

Chúng ta có thể đưa một số dữ liệu vào nó bằng các sử dụng toán tử gán `=` :

```
let message;

message = 'Hello'; // lưu chuỗi
```

Chuỗi bây giờ được lưu vào vùng nhớ kết hợp tên biến. Chúng ta có thể truy cập nó bằng cách sử dụng tên biến:

```
let message;
message = 'Hello!';

alert(message); // hiển thị nội dung biến
```

Để ngắn gọn chúng ta có thể hợp nhất khao báo và gán thành một dòng đơn:

```
let message = 'Hello!'; // define the variable and assign the value

alert(message); // Hello!
```

Chúng ta cũng có thể khai báo nhiều biến trên một dòng:

```
let user = 'John', age = 25, message = 'Hello';
```

Điều đó có vã ngắn hơn, nhưng nó không được khuyến cáo. Để có thể dễ đọc hơn, vui lòng sử dụng một dòng một biến.

```
let user = 'John';
let age = 25;
let message = 'Hello';
```

**var thay vì let**

Trong các tập lệnh cũ hơn bạn cũng có thể tìm thấy từ khoá khác: var thay vì let.

`var message = 'Hello';`

Từ khoá var gần giống như let. Nó cũng tuyên bố một biến, nhưng nó hơi khác nhau,"old-school" thời trang.

## a real-life analogy (một phép so sánh thực tế)

Chúng ta cũng có thể khai báo hai biế và sao chép dữ liệu từ một trong các biến khác.

```
let hello = 'Hello world!';

let message;

// copy 'Hello world' from hello into message
message = hello;

// bây giờ hai biến cùng một kiểu dữ liệu
alert(hello); // Hello world!
alert(message); // Hello world!
```

## Variable naming

Có hai hạn chế đối với một tên biến trong JavaScript:

1.Tên chứa chữ cái, chữ số, ký hiệu $ và __ .

2. Ký tự đầu tiên không phải là chữ số.

Các tên hợp lệ :

```
let userName;
let test123;
```

Khi tên chứa nhiều từ, camelCase thường được sử dụng. Đó là: các từ đi từng cái một, mỗi từ bắt đầu bằng chữ cái hoa: myVeryLongName.

Những tên hợp lệ:

```
let $ = 1; // declared a variable with the name "$"
let _ = 2; // and now a variable with the name "_"

alert($ + _); // 3
```

Những tên không hợp lệ:

```
let 1a; // không được bắt đầu bằng số.

let my-name; // a hyphen không được có dấu - trong tên.
```

Tên biến có phân biệt hoa thường.

Tên biến có thể sử dụng bất ký ngôn ngữ nào

Tên biến không được trùng với từ khoá.

```
let let = 5; // 
let return = 5; //
```

**Một nhiệm vụ mà không có use strict**

```
// note: không sử dụng use strict trong ví dụ

num = 5; // biến num được khởi tạo nếu không tồn tại

alert(num); // 5
```

```
"use strict";

num = 5; // biến num không được khởi tạo.
```

## Constant (hằng số)

Để khai báo biến (không thay đổi) liên tục, ta sử dụng `const` thay vì `let`:

`const myBirthday = '18.04.1982';`

Biến được khai báo sử dụng `const` là các hằng số. Họ không thể thay đổi. Một nỗ lực để làm điểu đó sẽ gây ra một lỗi:

```const myBirthday = '18.04.1982';

myBirthday = '01.01.2001'; // error, không thể chỉnh lại hằng số!
```

Khi một lập trình viên chắc chắn rằng biến không bao giờ nên thay đổi, ông có thể sử dụng `const` để đảm bảo nó, và cũng để rõ ràng cho thấy rằng thực tế cho tất cả mọi người.

## Uppercase constants (hằng số trên)

```
const COLOR_RED = "#F00";
const COLOR_GREEN = "#0F0";
const COLOR_BLUE = "#00F";
const COLOR_ORANGE = "#FF7F00";

// ...when we need to pick a color
let color = COLOR_ORANGE;
alert(color); // #FF7F00
```

## Name things right (đặt tên đúng)

Hãy đặt tên biến hợp lý. Dành thời gian để suy nghĩ nếu cần thiết.

Đặt tên biến là một trong những kỹ năng quan trọng và phức tạp nhất trong lập trình. Một cáu nhìn nhanh về các tên biến có thể tiết lộ mã nào được viết bởi người mới bắt đầu và một người phát triển có kinh nghệm.

Trong một dự án thưc, phần lớn thời gian dành cho việc sữa đổi và mở rộng cơ sở mã hiện tại, hơn là viết một cái gì đó hoàn toàn tách biệt khởi đầu. Và khi chúng tôi trở lại mã sau một thời giam làm điều gì đó khác, thì dễ dàng hơn nhiều để tìm thông tin được gắn nhãn tốt. Hay nói cách khác, khi các biến cso tên tốt.

## Summary (tóm lược)

Chúng ta có thể khai báo các biến để lưu trữ dũ liệu. Điều đó có thể được thực hiện bằng cách sử dụng var hoặc let hoặc const.

## Task

**Working with variables**

```
<!DOCTYPE html>
<html>
<head>
    <title>huyen tran</title>
</head>
<body>

<b>hung le</b>
<script src="qưe.js"></script>
</body>
</html>
```

```
let admin;
let name;
name = 'John';
admin = name;
alert(admin);
```

**Giving the right name**

`let ourPlanet;` tên biến hành tinh của chúng ta.

`let newCurrent;` tên biến khách hàng hiện tại.

<a name="5"></a>
# 5. Data types

Một biến trong JavaScript có thể chứ bất kỳ dữ liệu nào. Một biến có thể tạo một thời điểm là một chuỗi và sau đó nhận được một giá trị số:

```
// no error
let message = "hello";
message = 123456;
```

## A number

Loại số dùng cho cả số nguyên và số dấu chấm động. Có nhiều hoạt động cho số, ví dụ: Nhân *, chia /, cộng +, trừ - và vân vân. Bên cạnh các số thường xuyên, còn có cái gọi là "giá trị số đặc biệt" thuộc loại đó: Infinity, -Infinity và NaN.

**Infinity**

`alert( 1 / 0 ); // Infinity`

`alert( Infinity ); // Infinity`

**NaN**

`alert( "not a number" / 2 + 5 ); // NaN`

Nếu có NaN một nơi nào đó trong một biểu thức toán học, nó lan truyền toàn bộ kêt quả.

**Hoạt động toán học an toàn**

Thực hành toán học là an toàn trong JavaScript. Chúng ta có thể làm bất cứ điều gì: chia cho số không, xử lý chuỗi không phải số như số, vv

Script sẽ không bao giờ dừng lại với một lỗi chết người ("chết"). Trong tồi tệ nhất, chúng tôi sẽ nhận được NaN như là kết quả.

## A String

Một chuỗi trong JavaScript phải dduocj trích dẫn.

```
let str = "Hello";
let str2 = 'Single quotes are ok too';
let phrase = `can embed ${str}`;
```

Backticks là mở rộn chức năng báo giá. Chúng cho phép nhúng biến vào biểu thức vafp một chuỗi bằng cách gói chúng trong ${...}:

```
let name = "John";

// embed a variable
alert( `Hello, ${name}!` ); // Hello, John!

// embed an expression
alert( `the result is ${1 + 2}` ); // the result is 3
```

## A boolean (logical type)

là kiểu gồm hai giá trị là true và false.

```
let nameFieldChecked = true; // yes, name field is checked
let ageFieldChecked = false; // no, age field is not checked
```

```
let isGreater = 4 > 1;

alert( isGreater ); // true (the comparison result is "yes")
```

## Giá trị Null

`let age = null;`

## The “undefined” value (giá trị không xác định)

Giống như null

Ý nghĩa là giá trị không được gán.

```
let x;

alert(x); // shows "undefined"
```

Về mặt kỹ thuật có thể gán bất kỳ biến nào thành undefined:

```
let x = 123;

x = undefined;

alert(x); // "undefined"
```

## Objects and Symbols (đồi tượng và ký hiệu)

## The typeof operator (toán tử typeof)

Toán từ typeof trả về kiểu đối số. Điều này rất hữu ích khi chúng tôi muốn xử lý các giá trị khác nhau theo kiểu khác nhau hoặc chỉ muốn thực hiện kiểm tra nhanh.

Nó hỗ trợ hai dạng cú pháp

`tyoeof x;`

`typeof(x);`



## Summary

`number` cho bất kỳ dạng nào: số nguyên hoặc số có dấu chấm động.

`string` cho một chuỗi. Một chuỗi có thể có một hoặc nhiều ký tự, không có loại ký tự đơn lẻ.


`boolean` for `true/false`

`null` cho các giá trị không xác định - một loại đôc lập có một giá trị null.

`undefined` cho giá trị chưa được gán - một loại đọc lập có một giá trị duy nhất chưa được xác định.

`object` cho các cấu trúc dữ liệu phức tạp hơn.

`symbol` cho các định danh duy nhất.

## Task

```
let name = "Ilya";

alert( `hello ${1}` ); // 1

alert( `hello ${"name"}` ); // name

alert( `hello ${name}` ); // Ilya
```

<a name="6"></a>
# 6. Type Conversions.(chuyển đổi loại)

## ToString

```
let value = true;
alert(typeof value); // boolean

value = String(value); // now value is a string "true"
alert(typeof value); // string
```

Việc chuyển đổi chuỗi rõ ràng là rõ ràng. Một false trở thành "false", null trở thành "null" ...

## ToNumber

Chuyển đổi số sẽ xảy ra trong các hàm và biểu thức toán học tự động. Ví dụ, khi phân chia / được áp dụng cho các số không:


`alert( "6" / "2" ); // 3, strings are converted to numbers`

```
let str = "123";
alert(typeof str); // string

let num = Number(str); // becomes a number 123

alert(typeof num); // number
```

Việc chuyển đổi rõ ràng thường được yêu cầu khi chúng ta đọc một giá trị từ một nguồn dựa trên chuỗi như một mẫu văn bản, nhưng chúng tôi mong đợi một số được nhập.

Nếu chuỗi không phải là một số hợp lệ, kết quả của việc chuyển đổi như vậy là NaN, ví dụ:

```
let age = Number("an arbitrary string instead of a number");

alert(age); // NaN, conversion failed
```

Quy tắc chuyển đổi số:

<img src="http://sv1.upsieutoc.com/2017/07/05/153110.png">

```
alert( Number("   123   ") ); // 123
alert( Number("123z") );      // NaN (error reading a number at "z")
alert( Number(true) );        // 1
alert( Number(false) );       // 0
```

Xin lưu ý rằng null và undefined cư xử một cách khác nhau ở đây: null trở thành một số không, trong khi undefined trở thành NaN.

**Thêm '+' nối các xâu**

```
alert( 1 + '2' ); // '12' (string to the right)
alert( '1' + 2 ); // '12' (string to the left)
```

Điều đó chỉ xảy ra khi một trong những đối số là một chuỗi. Nếu không, các giá trị được chuyển thành số.

## ToBoolean

```
alert( Boolean(1) ); // true
alert( Boolean(0) ); // false

alert( Boolean("hello") ); // true
alert( Boolean("") ); // false
```

Boolean chuyển đổi là một trong những đơn giản nhất.

Nó sẽ xảy ra trong các hoạt động hợp lý (sau đó chúng ta sẽ đáp ứng các bài kiểm tra điều kiện và các loại khác của chúng), nhưng cũng có thể được thực hiện bằng tay với các cuộc gọi của Boolean (giá trị).

Quy tắc chuyển đổi:

Các giá trị vô nghĩa "trống rỗng", như 0, một chuỗi rỗng, null, undefined và NaN trở nên sai.

Các giá trị khác trở thành sự thật

Xin lưu ý: chuỗi với số không "0" là đúng

```
alert( Boolean("0") ); // true
alert( Boolean(" ") ); // spaces, also true (any non-empty string is true)
```

## Task

```
"" + 1 + 0 //10
"" - 1 + 0 // -1
true + false // 1
6 / "3" // 2
"2" * "3" // 6
4 + 5 + "px" // 9px
"$" + 4 + 5 // $45
"4" - 2 // 2
"4px" - 2 //NaN
7 / 0 // Infinity
"  -9\n" + 5 // 9 5
"  -9\n" - 5 // -14
null + 1 // 1
undefined + 1 // NaN
```

<a name="7"></a>
# 7.Operators (nhà khai thác)

## Thuật ngữ: "unary", "binary", "operand"

```
let x = 1;

x = -x;
alert( x ); // -1, unary negation was applied
```


```
let x = 1, y = 3;
alert( y - x ); // 2, binary minus subtracts values
```

## Strings concatenation, binary + (Ghép nối, nhị phân +)

Nối chuỗi:

```
let s = "my" + "string";
alert(s); // mystring
```

Nối chuỗi số:

```
alert( '1' + 2 ); // "12"
alert( 2 + '1' ); // "21"
```

Ví dụ phép trừ và phép chia:

```
alert( 2 - '1' ); // 1
alert( '6' / '2' ); // 3
```

## Numeric conversion, unary + (chuyển đổi số, unary +)

```
// không ảnh hưởng đến số.
let x = 1;
alert( +x ); // 1

let y = -2;
alert( +y ); // -2

// Chuyển đổi số không
alert( +true ); // 1
alert( +"" );   // 0
```

Nó thực sự làm giống Num(...) nhưng ngắn hơn.

```
let apples = "2";
let oranges = "3";

alert( apples + oranges ); // "23", các nhị phân cộng với nối chuỗi
```

Nếu chúng ta muốn đối xử với chúng như số, sau đó chúng ta có thể chuyển đổi và sau đó tổng hợp:

```
let apples = "2";
let oranges = "3";

// các giá trị được chuyển đổi thành số sau khi cộng nhị phân
alert( +apples + +oranges ); // 5

// biến thể dài hơn
// alert( Number(apples) + Number(oranges) ); // 5
```

## Operators precedence (toán tử ưu tiên)

Nếu một biểu thức có nhiều toán tử, thứ tự thực hiện được xác định bởi sự ưu tiên của chúng, hoặc, nói cách khác, có một trật tự ưu tiên ẩn trong các toán tử.

Nếu sự ưu tiên là như nhau - lệnh thực hiện là từ trái sang phải.

Trích dẫn bảng ưu tiên:

<img src="http://sv1.upsieutoc.com/2017/07/06/2.png">

## Assignment (chuyển nhượng)

```
let x = 2 * 2 + 1;

alert( x ); // 5
```

Có thể phân công chuỗi:

```
let a, b, c;

a = b = c = 2 + 2;

alert( a ); // 4
alert( b ); // 4
alert( c ); // 4
```

```
let a = 1;
let b = 2;

let c = 3 - (a = b + 1);

alert( a ); // 3
alert( c ); // 0
```

Trong ví dụ trên, kết quả của (a = b + 1) là giá trị được gán cho a (nghĩa là 3). Sau đó nó được sử dụng để trừ từ 3.

## Remainder % (chia phền dư)

```
alert( 5 % 2 ); // dư 1
alert( 8 % 3 ); // dư 2
alert( 6 % 3 ); // dư 0
```

## Exponentiation ** (luỹ thừa)

```
alert( 2 ** 2 ); // 4  (2 * 2)
alert( 2 ** 3 ); // 8  (2 * 2 * 2)
alert( 2 ** 4 ); // 16 (2 * 2 * 2 * 2)
```

```
alert( 4 ** (1/2) ); // 2 
alert( 8 ** (1/3) ); // 2
```

##  Increment/decrement (tằng/giảm)

**Incrediment** `++` tăng 1 đơn vị.

```
let counter = 2;
counter++;      
alert( counter ); // 3
```

**Decrement** `--` giảm một đơn vị.

```
let counter = 2;
counter--;     
alert( counter ); // 1
```

## Bitwise operators (toán tử bitwise)

AND ( & )

OR ( | )

XOR ( ^ )

NOT ( ~ )

LEFT SHIFT ( << )

RIGHT SHIFT ( >> )

ZERO-FILL RIGHT SHIFT ( >>> )

## Modify-in-place

```
let n = 2;
n = n + 5;
n = n * 2;
```

```
let n = 2;
n += 5; // now n=7 (same as n = n + 5)
n *= 2; // now n=14 (same as n = n * 2)

alert( n ); // 14
```

```
let n = 2;

n *= 3 + 5;

alert( n ); // 16
```

## Comma

```
let a = (1+2, 3+4);

alert( a ); // 7 (the result of 3+4)
```

Ở đây, biểu thức đầu tiên bị ném đi, sau đó 3+4 được đánh giá và trả về kết quả.

## Task

```
let a = 1, b = 1;

let c = ++a; // 2
let d = b++; // 1
```

```
let a = 2;

let x = 1 + (a *= 2);

// a=4
// x = 5
```

<a name="8"></a>
# 8. Comparisons (so sánh)
 
 Các toán tử so sánh:
  `> <` lớn, bé

  `>= , <=` lớn hơn hoặc bằng, bé hơn hoặc bằng.

  `==` toán tử so sánh

  `!=` phủ định phép bằng

  ## Boolean is the result (boolean là kết quả)

  ```
alert( 2 > 1 );  // true (correct)
alert( 2 == 1 ); // false (wrong)
alert( 2 != 1 ); // true (correct)
  ```


```
let result = 5 > 4; // gán kết quả cho sụ so sánh.
alert( result ); // true
```

## String comparison (so sánh chuỗi)

```
alert( 'Z' > 'A' ); // true
alert( 'Glow' > 'Glee' ); // true
alert( 'Bee' > 'Be' ); // true
```

Thuật toán để so sánh chuỗi đơn giản.

1. So sánh ký tự đầu tiên của hai dãy.
2. Nếu đầu tiên lè lớn hơn (hoặc ít hơn), sau đó chuỗi đầu tiên lơn hơn (hoặc ít hơn) thứ hai. Đã được thực hiện.
3. Nếu không, nếu các ký tự đầu tiên bằng nhau, so sánh các ký tự thứ hai theo cùng một cách.
4.  Lặp lại cho đến khi kế thúc chuỗi bất kỳ.
5.  Nếu hai chuỗi kết thúc cùng một lúc thì hai chuỗi đều bằng nhau. Nếu không thì chuỗi dài hơn lớn hơn.

## Comparison of different types (so sánh các loại khác nhau)

Khi so sánh các giá trị thuộc về các loại khác nhau, chúng được chuyển đổi thành các con số.

```
alert( '2' > 1 ); // true, chuỗi 2 được chuyển thành số 2
alert( '01' == 1 ); // true, chuỗi 01 được đổi thành số 1.

```

```
alert( true == 1 ); // true
alert( false == 0 ); // true
```

```
let a = 0;
alert( Boolean(a) ); // false

let b = "0";
alert( Boolean(b) ); // true

alert(a == b); // true!
```

## Strict equality (bình đẳng nghiêm ngặt)

`alert( '' == false ); // true` Một chuỗi rỗng được chuyển thành số 0.


**Kiểm tra sự bằng nhau mà không chuyển đổi kiểu**

`alert( 0 === false ); // false, bởi vì hai loại khác nhau`

## Comparison with null and undefined (so sánh với null và undefined)

**Đối với kiểm tra nghiêm ngặt ====**

`alert( null === undefined ); // false`

**Đối với kiểm tra không nghiêm ngặt**

`lert( null == undefined ); // true`

**Đối với toán học và so sánh khác <> <=> =**

Các giá trị null / undefined được chuyển thành một số: null trở thành 0, trong khi undefined trở thành NaN.


## Strange result: null vs 0 (kết quả lạ: null và 0)

```
alert( null > 0 );  // (1) false
alert( null == 0 ); // (2) false
alert( null >= 0 ); // (3) true
```

## An incomparable undefined (một undefined không xác định)


```
alert( undefined > 0 ); // false (1)
alert( undefined < 0 ); // false (2)
alert( undefined == 0 ); // false (3)
```

## Summary (tóm lược)

Các toán tử so sánh mang lại một giá tị logic.

Các chuỗi trên được so sánh theo từng chữ trong trật tự từ điển.

Khi so sánh các giá trị của các loại khác nhau, chúng sẽ được chuyển đổi thành các con số (với việc loại trừ kiểm tra tính bình đẳng nghiêm ngặt).

Các giá trị null và undefined bằng `==` và không bằng bất kỳ giá trị nào khác.

Hãy cẩn thận khi sử dụng so sánh như `>` hoặc `<` với các biến mà thỉnh thoảng có thể được null/undefined. Làm cmootj kiểm tra riêng biệt cho null/ undifened là một ý tưởng tốt.

## Task

```
5 > 4 // true
"apple" > "pineapple" // fale
"2" > "12" // true
undefined == null // true
undefined === null false
null == "\n0\n" // false
null === +"\n0\n" // false
```


<a name="9"></a>
# 9. Interaction: alert, prompt, confirm (tương tác: alert, prompt, confirm)

## alert

`alert(message);`

`alert("Hello");`

## prompt

`result = prompt(title[, default]);`

Nó cho thấy một cửa sổ modal với một tin nhắn văn bản, một trường cho khách truy cập các nút OK / CANCEL.

**title**

Văn bản hiển thị cho khách truy cập.

**dafault**

Một tham sso thứ hai tuỳ chọn, giá trị ban đầu cho trường đầu vào.

```
let age = prompt('How old are you?', 100);

alert(`You are ${age} years old!`); // You are 100 years old!
```

<img src="http://sv1.upsieutoc.com/2017/07/06/30c332.png">

<img src="http://sv1.upsieutoc.com/2017/07/06/427691.png">

## confirm

`result = confirm(question);`

Chức năng xác nhận cho thấy một cửa sổ modal vơi một câu hỏi và hai nút: OK và CANCEL.

Kết quả là đúng nếu OK được ấn và sai nếu không.

```
let isBoss = confirm("Are you the boss?");

alert( isBoss ); // true if OK is pressed
```


## Summary (tóm lược)

**alert** show thông báo

**prompt** Hiển thị thông báo yêu cầu người dùng nhập văn bản. Nó trả về văn bản hoặc, nếu CANCEL hoặc Esc được nhấp vào, tất cả các trình duyệt ngoại trừ Safari trả về null.

**confirm** Hiển thị một thông báo và chờ người dùng nhấn OK hoặc CANCEL. Nó trả về true cho OK và false cho CANCEL/Esc.

## Task

```
<!DOCTYPE html>
<html>
<head>
    <title>huyen tran</title>
</head>
<body>

<b>hung le</b>
<script src="qưe.js"></script>
</body>
</html>
```

```
let test = prompt("Tên của bạn...");

alert(test);
```

<img src="http://sv1.upsieutoc.com/2017/07/06/16c63f.png">

<img src="http://sv1.upsieutoc.com/2017/07/06/2c7016.png">

<a name="10"></a>
# 10. Conditional operators: if, '?'.



Đôi khi (sometimes) chúng ta cần thực hiện (perform) các hành động (action) khác nhau dựa trên một điều kiện (condition).

 Có một toán tử IF cho điểu đó và cũng là toán tử "question mark" : "?" Để đánh giá có điều kiện.

 ## The "if" operator

 ```
let year = prompt('In which year was ECMAScript-2015 specification published?', '');

if (year == 2015) alert( 'You are right!' );
 ```


## Boolean conversion (chuyển đổi boolean)

Một số 0, một chuỗi rỗng "", null, undefined và NaN trở nên sai. Do đó chúng được gọi là giá trị "giả tạo".

Các giá trị khác trở thành sự thật, vì vậy chúng trở thành chân lý. (truthy)


## The "else" clause (mệnh đề else)

```
let year = prompt('In which year was ECMAScript-2015 specification published?', '');

if (year == 2015) {
  alert( 'You guessed it right!' );
} else {
  alert( 'How can you be so wrong?' ); // any value except 2015
```

## Several conditions: “else if” (Mệnh đề "else if")

```
let year = prompt('In which year was ECMAScript-2015 specification published?', '');

if (year < 2015) {
  alert( 'Too early...' );
} else if (year > 2015) {
  alert( 'Too late' );
} else {
  alert( 'Exactly!' );
}
```

## Ternary operator ‘?’

Đôi khi chúng ta cần gán một biến phụ thuộc vào điều kiện.

```
let accessAllowed;
let age = prompt('How old are you?', '');

if (age > 18) {
  accessAllowed = true;
} else {
  accessAllowed = false;
}

alert(accessAllowed);
```

Toán tử này được đại diện bởi một dấu chấm hỏi "?" thuật ngữ chính thức "ternary" có nghĩa là toán tử có 3 toán hạng. Nó thực sự là một trong những nhà điều hành duy nhất trong JavaScript mà có rất nhiều.

Cú pháp là:

`let result = condition ? value1 : value2`

Nếu đúng thì trả về giá trị 1, nếu sai thì trả về giá trị 2.

VD:
`let accessAllowed = (age > 18) ? true : false;`

## Multiple '?'

Một dãy dấu chấm hỏi "?" Các toán tử cho phép trả lại một giá trị tuỳ thuộc vào nhiều điều kiện.

```
let age = prompt('age?', 18);

let message = (age < 3) ? 'Hi, baby!' :
  (age < 18) ? 'Hello!' :
  (age < 100) ? 'Greetings!' :
  'What an unusual age!';

alert( message );
```

Nó là một chuỗi các kiểm tra thông thường.


## Non-traditional use of ‘?’ (Không truyền thông bởi "?")

Đôi khi dấu hỏi '?' được sử dụng như một sự thay thế nếu:

```
let company = prompt('Which company created JavaScript?', '');

(company == 'Netscape') ?
   alert('Right!') : alert('Wrong.');
```

**Không nên sử dụng toán tử đánh dấu câu hỏi theo cách này.**

```
let company = prompt('Which company created JavaScript?', '');

if (company == 'Netscape') {
  alert('Right!');
} else {
  alert('Wrong.');
```

## Task

**Show the sign**

```
let hung = prompt ("Nhập vào một số: ",'number');

if(hung > 1)
{
    alert(1);
}
else if (hung < 1) 
{
    alert(-1);
}
else 
{
    alert(0);
}
```

**Check the login**

```
let hung = prompt ("Who is there ?");

if(hung == "Cancel")
{
    alert("Canceled");
}
else if (hung == "Other") 
{
    alert("I don't know you.");
}
else if(hung == "Admin")
{
    let le = prompt ("Password?");

    if(le == "Cancel")
    {
        alert("Canceled");
    }
    else if (le == "Other") 
    {
        alert("Wrong password");
    }
    else if( le == "TheMaster")
        {
            alert("Welcome!");
        }
}
```

**Rewrite 'if' into '?'**

```
const a = 1;
const b = 1;

(a+b < 4) ? alert('Below') : alert('Over');
```

**Rewrite 'if..else' into '?'**

```
let message;

let login = prompt('nhập: ');

(login == 'Employee') ? message = 'Hello' : (login == 'Director') ? message = 'Greetings' : (login == '') ? message = 'No login' : '';

alert (message);
```

<a name="11"></a>
# 11.Logical operators (Toán tử logic )

## || (OR)

`result = a || b;`

Ví dụ:

```
alert( true || true );   // true
alert( false || true );  // true
alert( true || false );  // true
alert( false || false ); // false
```

## OR seeks the first truthy value ( Tìm giá trị xác thực đầu tiên.)

`result = value1 || value2 || value3;` so sánh từ trái quá và lấy giá trị đúng.

```
alert( 1 || 0 ); // 1 (1 is truthy)
alert( true || 'no matter what' ); // (true is truthy)

alert( null || 1 ); // 1 (1 is the first truthy value)
alert( null || 0 || 1 ); // 1 (the first truthy value)
alert( undefined || null || 0 ); // 0 (all falsy, returns the last value)
```

## && (AND)

`result = a && b;`

```
alert( true && true );   // true
alert( false && true );  // false
alert( true && false );  // false
alert( false && false ); // false
```

```
let hour = 12;
let minute = 30;

if (hour == 12 && minute == 30) {
  alert( 'Time is 12:30' );
}
```


## AND seeks the first falsy value

`result = value1 && value2 && value3;`

Hoạt động:

Đánh dấu toán hạng từ trái sang phải.

Đối với mỗi giá trị chuyển nó thành một boolean. Nếu kết quả sai, dừng lại và trả về giá trị ban đầu.

Nếu giá trị kết thúc, trả về giá trị cuối cùng.

**Thứ tự của toán tử AND && là cao hơn OR ||, do đó nó được thực thi trước OR.

`alert( 5 || 1 && 0 ); // 5`

## ! (NOT)

`result = !value;`

Chuyển đổi toán hạng thành kiểu boolean: true / false.

Trả về giá trị nghịch đảo.

```
alert( !true ); // false
alert( !0 ); // true
```

Một đôi NOT !! đôi khi được sử dụng để chuyển đổi một giá trị sang kiểu boolean:

```
alert( !!"non-empty string" ); // true
alert( !!null ); // false
```

Tương tự:

```
alert( Boolean("non-empty string") ); // true
alert( Boolean(null) ); // false
```

## Task

What the code below is going to output?

`alert( null || 2 || undefined ); // 2`

What's the result of OR'ed alerts?

`alert( alert(1) || 2 || alert(3) ); //1  2`

What is the result of AND?

`alert( 1 && null && 2 ); // null`

What is the result of AND'ed alerts?

`alert( alert(1) && alert(2) ); // 1 undefined`

The result of OR AND OR

`alert( null || 2 && 3 || 4 ); //3`

Check the range between

`if (age >= 14 && age <= 90)`

Check the range outside

`if (!(age >= 14 && age <= 90))`  || `if (age < 14 || age > 90)`

A question about "if"

```
if (-1 || 0) alert( 'first' ); //first
if (-1 && 0) alert( 'second' ); // không chạy
if (null || -1 && 1) alert( 'third' ); //third
```


<a name="12"></a>
# 12.Loops: while and for (vòng lặp)

## The “while” loop (Vòng lặp while)

```
while (điều kiện) {
  // code
  // so-called "loop body"
}
```

Điều kiện đúng thì code mới được thực hiện.

```
let i = 0;
while (i < 3) { // shows 0, then 1, then 2
  alert( i );
  i++;
}
```

```
let i = 3;
while (i) { // khi i ==0 điều kiện sai kết thúc vòng lặp.
  alert( i );
  i--;
}
```

## The “do…while” loop (vòng lặp do...while)

```
do {
  // loop body
} while (condition);

```

Vòng lặp thục hiện 1 lần sau đó kiểm tra điều kiện, nếu đúng thì vòng lặp thục hiện thêm một lần nữa.

```
let i = 0;
do {
  alert( i );
  i++;
} while (i < 3);
```

## The “for” loop (Vòng lặp for)

Vòng lặp thường được sử dụng nhất.

```
for (begin; condition; step) {
  // ... loop body ...
}
```

```
for (let i = 0; i < 3; i++) { // shows 0, then 1, then 2
  alert(i);
}
```

## Breaking the loop

```
let sum = 0;

while (true) {

  let value = +prompt("Enter a number", '');

  if (!value) break; // (*)

  sum += value;

}
alert( 'Sum: ' + sum );
```

Chỉ thị thoát khỏi vòng lặp ở dòng * .

## Continue to the next iteration (continue tron lần kế tiếp.)

 Continue không dừng lại vòng lặp, thay vào đó, nó dừng lại sự lặp lại hiện tại và bắt buộc vòng lặp bắt đầu vòng lặp mới.

 Ví dụ vòng lặp tìm ra số lẽ:

 ```
for (let i = 0; i < 10; i++) {

  
  if (i % 2 == 0) continue; //nếu điều kiện đúng thì bỏ qua giá trị và thực hiện vòng lặp tiếp theo.

  alert(i); // 1, then 3, 5, 7, 9
}
 ```

 Ví dụ khác về in ra số lẽ:

 ```
for (let i = 0; i < 10; i++) {

  if (i % 2) {
    alert( i );
  }
}
 ```

**Chú ý**

`(i > 5) ? alert(i) : continue; // continue không được dùng ở đây.`

## Labels for break/continue (Nhãn cho break/continue)

Cú pháp:

```
labelName: for(...) {
...
}

```

Câu lệnh break nằm trong vòng lặp phá vỡ nhãn.

```
outer: for (let i = 0; i < 3; i++) {

  for (let j = 0; j < 3; j++) {

    let input = prompt(`Value at coords (${i},${j})`, '');

    // if an empty string or canceled, then break out of both loops
    if (!input) break outer; // (*)

    // do something with the value...
  }
}
alert('Done!');
```

Nhãn cũng có thể dùng cho `continue` trong trường hợp này nhảy đến vòng lặp kế tiếp.

**Nhãn không phải "goto"**

Nhãn không cho phép nhảy vào nơi mã tuỳ ý.

```
break label;  // jumps to label? No.

label: for(...)
```

Cuộc gọi đến break/continue chỉ có thể thực hiện từ bên trong vòng lặp, và nhãn phải ở đâu đó trên đầu từ hướng dẫn

## Tóm lược

Có 3 vòng lặp:

- while - kiểm tra điều kiện trước khi thực kiện.
- do..while - thực hiện một lần rồi mới kiểm tra điều kiện.
- for(;;) - điều kiện được kiểm tra trước mỗi lần lặp, cài đặt bổ xung có sẵn.

Break/Continue hỗ trợ nhãn trước khi vòng lặp.

## Task

What is the last value alerted by this code? Why?

```
let i = 3;

while (i) {
  alert( i-- ); // Giá trị cuối là 1 vì i-- .
}
```


Which values shows the while?

```
let i = 0;
while (++i < 5) alert( i ); // 1 2 3 4
```

```
let i = 0;
while (i++ < 5) alert( i ); // 1 2 3 4 5
```

Which values get shown by the "for" loop?

```
for (let i = 0; i < 5; i++) alert( i ); // 0 1 2 3 4
```

```
for (let i = 0; i < 5; ++i) alert( i ); // 0 1 2 3 4 
```

Output even numbers in the loop

```
for (let i = 2 ; i<= 10 ; i++)
    {
        alert(i);
    }
```

Replace "for" with "while"

```
let i = 0;
while(i<3)
{
     alert( `number ${i}!` );
    i++;
}
```

Repeat until the input is incorrect

```
let num;

 do
{
     num = prompt("Nhập vào một số:");
    if(num > 100)
    {
        alert("Vui lòng nhập lại !");
    }
} while(num > 100);

alert(`Số bạn vừa nhập là ${num}.`);
```

```
let num;

 do
{
     num = prompt("Nhập vào một số:");
     if(num == '')
    {
        break;
    }
    if(num < 100)
    {
        alert("Vui lòng nhập lại !");
    }
    
} while(num < 100);

alert(`Số bạn vừa nhập là ${num}.`);
```

Output prime numbers

```
let num = prompt("Nhập vào một số:");

next :
for ( let i = 2 ; i <= num ; i++)
{
    for ( let j = 2 ; j < i ; j++)
    {
        if(i%j == 0) continue next;
    }

    alert(i);
}

```

<a name="13"></a>
# 13. The "switch" statement.

Cú pháp:

```
switch(x) {
  case 'value1':  // if (x === 'value1')
    ...
    [break]

  case 'value2':  // if (x === 'value2')
    ...
    [break]

  default:
    ...
    [break]
}
```

Ví dụ:

```
let a = 2 + 2;

switch (a) {
  case 3:
    alert( 'Too small' );
    break;
  case 4:
    alert( 'Exactly!' );
    break;
  case 5:
    alert( 'Too large' );
    break;
  default:
    alert( "I don't know such values" );
```

Nếu không có break thì việc thực hiện tiếp tục với trường hợp tiếp theo mà không có bất kỳ kiểm tra.

Ví dụ:

```
let a = 2 + 2;

switch (a) {
  case 3:
    alert( 'Too small' );
  case 4:
    alert( 'Exactly!' );
  case 5:
    alert( 'Too big' );
  default:
    alert( "I don't know such values" );
```

## Grouping of “case” (nhóm các trường hợp)

```
let a = 2 + 2;

switch (a) {
  case 4:
    alert('Right!');
    break;

  case 3:                    // (*) grouped two cases
  case 5:
    alert('Wrong!');
    alert("Why don't you take a math class?");
    break;

  default:
    alert('The result is strange. Really.');
}
```

## Task

Rewrite the "switch" into an "if"

```
let browser = prompt("Nhập vào tên trình duyệt bạn đang sử dụng");

if(browser == 'Edge')
{
    alert("You have got the Edge.");
}
else if (browser == 'Chrome' || browser == 'Firefox' || browser == 'Safari' || browser == 'Opera')
{
    alert("Okey we support these browser too");
}
else
{
    alert("We hope that this page looks ok!");
}
```

Rewrite "if" into "switch"

```
let a = +prompt("a = ?");

switch(a)
{
    case 0: alert(0); break ;
    case 1: alert(1); break ;
    case 2:
    case 3: alert('2,3'); break;
}
```

<a name="14"></a>
# 14. Functions.

## Function Declaration

Để tạo một hàm ta sử dụng khai báo hàm.

```
function showMessage() {
  alert( 'Hello everyone!' );
}
```


Ví dụ:

```
function showMessage() {
  alert( 'Hello everyone!' );
}

showMessage();
showMessage();
```

## Local variables

Một biến khai báo bên trong một hàm chỉ hiển thị bên trong hàm đó.

```
function showMessage() {
  let message = "Hello, I'm JavaScript!"; // local variable

  alert( message );
}

showMessage(); // Hello, I'm JavaScript!

alert( message ); // <-- Error! biến chỉ sử dụng trong hàm, không được gọi ra ngoài.
```

## Outer variables

```
let userName = 'John';

function showMessage() {
  let message = 'Hello, ' + userName;
  alert(message);
}

showMessage(); // Hello, John
```

Hàm có toàn quyền truy cập vào biến ngoài. NÓ cũng có thể sữa đổi nó.

```
let userName = 'John';

function showMessage() {
  userName = "Bob"; // (1) changed the outer variable

  let message = 'Hello, ' + userName;
  alert(message);
}

alert( userName ); // John before the function call

showMessage();

alert( userName ); // Bob, giá trị đã được sữa đổi bởi hàm.
```

```
let userName = 'John';

function showMessage() {
  let userName = "Bob"; // declare a local variable

  let message = 'Hello, ' + userName; // Bob
  alert(message);
}

// the function will create and use it's own userName
showMessage();

alert( userName ); // John, unchanged, the function did not access the outer variable
```

Username trong và ngoài hàm là khác nhau.

## Parameters (Thông số)

Chúng ta có thể truyền dữ liệu tuỳ ý đến chức năng sử dụng các tham số (Còn gọi là các đối số chức năng).

Ví dụ:

```
function showMessage(from, hung) { // arguments: from, text
  alert(from + ': ' + hung);
}
let from=prompt("Your name:");


showMessage(from, 'Hello!'); 
showMessage(from, "What's up?");
```

## Default values

Nếu một tham số không được cung cấp, thì giá trị của nó không được xác định.

```
function showMessage(from, text = "no text given") {
  alert( from + ": " + text );
}

showMessage("Ann"); // Ann: no text given
```

```
function showMessage(from, text  )
 {
 if(text == '')
 {
    text = "no text given";
 }
  alert( from + ": " + text );
}

let from = prompt("Your name:");
let text = prompt("Câu chào:");

showMessage(from,text); // Ann: no text given
```

…Or the || operator:

```
function showMessage(from, text) {
  // nếu văn bản bị sai lệch thì văn bản sẽ bị "default" value
  text = text || 'no text given';
  ...
}
```

## Returning a value

Một hàm có thể trả lại một giá trị trở lại vào mã gọi là result.

```
function sum(a, b) {
  return a + b;
}

let result = sum(1, 2);
alert( result ); // 3
```

Ví dụ:

```
function checkAge(age) {
  if (age > 18) {
    return true;
  } else {
    return confirm('Got a permission from the parents?');
  }
}

let age = prompt('How old are you?', 18);

if ( checkAge(age) ) {
  alert( 'Access granted' );
} else {
  alert( 'Access denied' );
}
```

Có thể sử dụng return mà không có giá trị. Điều đó làm cho các chức năng để thoát ra ngay lập tức.

Ví dụ:

```
function showMovie(age) {
  if ( !checkAge(age) ) {
    return;
  }

  alert( "Showing you the movie" ); // (*)
  // ...
}
```


Nếu một hàm không trả về một giá trị, thì nó cũng giống như nếu nó trả về undefined:

```
function doNothing() { /* empty */ }

alert( doNothing() === undefined ); // true
```

Nên đặt giá trị trên cùng một dòng:

```
return
 (some + long + expression + or + whatever * f(a) + f(b))
```

Ở đâu JavaScript ngầm hiểu dấu `;` sau `return`.

## Naming a function

Hàm là hành động. Vì vậy, tên của họ thường là một động từ. Nó nên ngắn gọn, nhưng chính xác nhất có thể mô tả những gì các chức năng nào. Vì vậy, để một người đọc mã nhận được đầu mối đúng.

Hàm bắt đầu với..

`get` trả về giá trị.

`calc` tính toán một cái gì đó.

`create..` tạo một cái gì đó.

`check..` tính toán một cái gì đó.

Ví dụ:

```
showMessage(..)     // hiển thị thông báo
getAge(..)          // trả về giá trị tuổi
calcSum(..)         // tính tổng và trả về giá trị
createForm(..)      // tạo form
checkPermission(..) // kiểm tra chức năng, trả về true/false.
```

Tên hàm nên ngắn gọn, nhưng mang tính mô tả.

## Functions == Comments

```
function showPrimes(n) {
  nextPrime: for (let i = 2; i < n; i++) {

    for (let j = 2; j < i; j++) {
      if (i % j == 0) continue nextPrime;
    }

    alert( i ); // a prime
  }
}

let n = prompt("N=");
showPrimes(n);
```

```
function showPrimes(n) {

  for (let i = 2; i < n; i++) {
    if (!isPrime(i)) continue;

    alert(i);  // a prime
  }
}

function isPrime(n) {
  for (let i = 2; i < n; i++) {
    if ( n % i == 0) return false;
  }
  return true;
}
```

## Tóm lược.

Khai báo hàm:

```
function name(thông số phân cách bởi dấu phấy
    ) {
  /* code */
}
```

Một hàm có thể trả về giá trị, nếu không thì nó undefined.

Để cho đoạn code gọn và dễ hiểu, nên sử dụng các biến địa phương và các tham số trong hàm chứ không phải bên ngoài.

Tên hàm:

Một cái tên mô tả chức năng của nó.

Có nhiều tiền tố nổi tiếng (well-known): create..,get..,check.. Sử dụng chúng để gợi ý một chức năng nào đó.

## Task

Is "else" required?

```
function checkAge(age) {
  if (age > 18) {
    return true;
  } else {
    // ...
    return confirm('Did parents allow you?');
  }
}
```

```
function checkAge(age) {
  if (age > 18) {
    return true;
  }
  // ...
  return confirm('Did parents allow you?');
}
```

Không có sự khác nhau.

**Rewrite the function using '?' or '||'**

```
function checkAge(age) {
  return (age > 18) ? true : confirm('Did parents allow you?');
}
```

```
function checkAge(age) {
  return (age > 18) || confirm('Did parents allow you?');
}
```

**Function min(a, b)**

```
function min(a,b)
{
    minn = a;
    if(a>b)
    {
        minn = b;
    }
    alert(minn);
}

let a =prompt("a =");
let b =prompt("b =");
min(a,b);
```

**Function pow(x,n)**

```
function pow(x,n)
{
    let m = x;
    for (let i = 1 ; i < n ; i++)
    {
         m *= x;
    }
    alert(m);
}

let x =prompt("x =");
let n =prompt("n =");
if(n<=1)
{
    alert("Không hợp lệ!!");
}
else
{
    pow(x,n);   
}

```

<a name="15"></a>
# 15. Function expressions and arrows (biểu thức hàm và mũi tên)

Hàm là một giá trị đặc biệt.

Cú pháp trước đây được gọi là Function Declaration

```
function sayHi() {
  alert( "Hello" );
}
```

Có một cú pháp khác để tạo ra một hàm được gọi là Function Expression.

```
let sayHi = function() {
  alert( "Hello" );
};
```


Ở đây, hàm được tạo ta và gán cho biến một cách rõ ràng, như bất kỳ giá trị nào khác. Không có vấn đề, là thế nào các chức năng không xác định - nó chỉ là một giá trị, được lưu trữ trong các biến `sayHi`.

Ý nghĩa của các mẫu mã này là như nhau: tạo một hàm và đặt nó vào biến `sayHi`

Chúng tôi có thể in ra giá trị sử dụng `alert`.

```
function sayHi() {
  alert( "Hello" );
}

alert( sayHi ); // shows the function code
```

Xin lưu ý rằng dòng cuối cùng không chạy các hàm, vì không có dấu ngoặc đơn sau sayHi.

Chúng ta có thể sao chép hàm đến một biến khác:

```
function sayHi() {   // (1) create
  alert( "Hello" );
}

let func = sayHi;    // (2) copy

func(); // Hello     // (3) run the copy (it works)!
sayHi(); // Hello    //     this still works too (why wouldn't it)
```

Nó hoạt động như sau:

1. Function Declaration (1) tạo ra một hàm và đặt nó vào biến có tên sayHi.
2. Dòng (2) sao chép nó vào biến func.
    Xin lưu ý một lần nữa: không có dấu ngoặc đơn sau khi sayHi.Nếu chúng được, sau đó func = sayHi() sẽ viết kết quả của cuộc gọi sayHi() vào function, chứ không phải hàm sayHi.
3.Bây giờ hàm có thể được gọi là cả hai như sayHi() và func().

Chú ý rằng chúng ta cũng có thể đã sử dụng một biểu thức hàm để khai báo sayHi, trong dòng đầu tiên:

```
let sayHi = function() { ... };

let func = sayHi;
// ...
```

Mọi thứ sẽ làm việc như nhau. Thậm chí rõ ràng hơn những gì đang xỹ ra, phải không?.

**Tại sao lại có một dấu chấm phẩy ở cuối?**

Có thể có một câu hỏi, tại sao Function Expression có một dấu chấm phẩy ; ở cuối, và chức năng.

Tuyên bố là không:

Không cần thiết trong; Ở cuối các khối mã và các cấu trúc cú pháp sử dụng chúng như nếu {...}, cho {}, function f {} vv

Hàm chức năng được sử dụng bên trong câu lệnh: let sayHi = ...; như một giá trị. Nó không phải là một khối mã. Dấu chấm phẩy ; được khuyến cáo ở cuối báo cáo, không có vấn đề về giá trị. Vì vậy, dấy chấm phẩy ở đây không liên quan đến Function Expression theo bất kỳ cách nào, nó chỉ chấm dứt câu lệnh.

```
function sayHi() {
  // ...
}

let sayHi = function() {
  // ...
};
```



## Callback functions (gọi lại hàm)

Hãy xem các ví dụ khác vê chuyển hàm dưới dạng các giá trị và sử dụng các biểu thức hàm.

Chúng ta sẽ viết một hàm `ask(question,yes,no)` với ba tham số:

`question` văn bản với câu hỏi.

`yes` hàm chạy với câu trả lời là "yes".

`no`  hàm không chạy với câu trả lời là "no".

```
function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}

function showOk() {
  alert( "You agreed." );
}

function showCancel() {
  alert( "You canceled the execution." );
}

// sử dụng: functions showOk, showCancel để hỏi
ask("Do you agree?", showOk, showCancel);
```

Bạn có thể sử dụng hàm để viết ngắn hơn.

```
function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}

ask(
  "Do you agree?",
  function() { alert("You agreed."); },
  function() { alert("You canceled the execution."); }
);
```

**Một hàm là một giá trị đại diện cho hành động.**

Các giá trị thông thường như chuỗi hoặc số đại diện cho dữ liệu.

Một hàm có thể hiểu như là một hành động.

Chúng ta có thể vượt qua nó giữa các biến và chạy khi chúng ta muốn.

## Function Expression vs Function Declaration

Hãy xây dựng sự khác biệt chính giữa các Function Declaration và Expressons.

Đầu tiên cú pháp: làm thể nào để xem những gì trong mã.

Function Declaration: một chức năng, tuyên bố như là một tuyên bố riêng biệt, trong dòng mã chính.

```
/ Function Declaration
function sum(a, b) {
  return a + b;
}
```

Function Expression: một hàm được tạo bên trong một biểu thức hoặc bên trong một cấu trúc cú pháp khác.

Ở đây, hàm được tạo ra bên phải của dấu `=`.

```
// Function Expression
let sum = function(a, b) {
  return a + b;
}
```

**Biểu thức hàm được tạo ra khi quá trình thực hiện được và có thể sử dụng kể từ đó.**

Function Declarations là khác nhau

**Function Declarations có thể sử dụng trong toàn bộ tập lệnh/khối mã.**

Hàm có thể gọi trước khi định nghĩa.

```
sayHi("John"); // Hello, John

function sayHi(name) {
  alert( `Hello, ${name}` );
}
```

Và nếu có Function Expression thì nó sẽ không hoạt động.

```
sayHi("John"); // error!

let sayHi = function(name) {  // (*) no magic any more
  alert( `Hello, ${name}` );
};
```

## Function Declaration trong một khối.

Khi khai báo hàm thì được thực hiện bên trong khối mã đó, nhưng bên ngoài thì không.

Code dưới đây không hoạt động:

```
let age = prompt("What is your age?", 18);

if (age < 18) {

  function welcome() {
    alert("Hello!");
  }

} else {

  function welcome() {
    alert("Greetings!");
  }

}

welcome(); // Error: welcome is not defined
```

Chúng ta có thể gọi nó từ một khối, nhưng không phải bên ngoài.

Ví dụ về code hoàn chỉnh

```
let age=prompt("Age = "); // take 16 as an example

if (age < 18) {
  welcome();               // \   (runs)
                           //  |
  function welcome() {     //  |
    alert("Hello!");       //  |  Function Declaration is available
  }                        //  |  everywhere in the block where it's declared
                           //  |
 // welcome();               // /   (runs)

} else {
   welcome();                        // \
  function welcome() {     //  |
    alert("Greetings!");   //  |  if age=16, the the execution does not go here,
  }                        //  |  so this "welcome" is never created
                           // /
}
```

Khi chúng ta khai báo một hàm, đầu tiên ta cần xem xét là cú pháp khai báo hàm, cái mà chúng ta sử dụng trước đây. Nó cho phép tự do hơn trong cách tổ chức mã của chúng ta, bởi vì chúng ta có thể gọi các hàm như vậy trước khi chúng được khai báo.

Nếu Function Declaration không phù hợp với chúng ta vì một số lý do, thì nên sử dụng Function Expression.

## Arrow functions (mũi tên hàm)

Có thêm một cú pháp để tạo ra các hàm - đơn giản và xúc tích. Nó được gọi là "arrow functions" bởi vì nó trông thế này.

Cú pháp:

`let func = (arg1, arg2, ...argN) => expression`

Nó giống như:

```
let func = function(arg1, arg2, ...argN) {
  return expression;
}
```

Ví dụ:

```
let sum = (a, b) => a + b;

alert( sum(1, 2) ); // 3
```

Nếu không có đối số, chúng ta có thể đặt dấu ngoặc vuông rỗng:

```
let sayHi = () => alert("Hello!");

sayHi();
```

Mũi tên hàm có thể được sử dụng như Function Expressions.

Ví dụ:

```
let age = prompt("What is your age?", 18);

let welcome = (age < 18) ?
  () => alert('Hello') :
  () => alert("Greetings!");

welcome(); // ok now
```

Cú pháp có thể xuất hiện không quen thuộc và không phải là rất dễ đọc lúc đầu, nhưng nhanh chóng thay đổi như đôi mắt được sử dụng để cấu trúc.

Mũi tên hàm rất thuận tiện cho các hành động đơn giản, khi lười để viết nhiều từ.

**Multiline arrow functions** Các chức năng mũi tên đa dòng.

Các ví dụ trên lấy các lập luận từ bên trái => và đánh giá biểu thức bên phải với chúng.

Đôi khi chúng ta cần một cái gì đó phức tạp hơn một chút, giống như nhiều biểu thức hoặc tuyên bố. Cũng có thể, nhưng kèm theo chúng trong các dấu ngoặc đơn. Sau đó, sử dụng một sự trở lại bình thường bên trong chúng.



```
let sum = (a, b) => {  // the figure bracket opens a multiline function
  let result = a + b;
  alert(result);
  //return result; // if we use figure brackets, must use return
};

//alert( sum(1, 2) ); // 3

sum(1,2);
```

Ở đây chúng tôi ca ngợi mũi tên hàm ngắn gọn nhưng đó không phải là tất cả! Mũi tên hàm có các tính năng thú vị khác.

## Tóm lược

Hàm là giá trị. Nó có thể được sao chép gán hoặc khai báo bất kỳ vị trí nào của mã.

Nếu hàm được khai báo như một câu lệnh riêng, trong dòng mã chính - được gọi mà "Function Declaration".

Nêu nó được tạo ra như một phần của một biểu thức - đó là "Function Expression".

Function Declaration được xử lý trước khi khối mã thực thi. Chúng có thể nhìn thấy ở khắp mọi nơi trong khối.

Trong hầu hết các trường hợp khi chúng ta cần khai báo một hàm, thì Function Declaration là thích hợp, bởi vì có thể nhìn thấy trước bản tuyên bố. Điều đó mang lại sự linh hoạt hơn trong việc tổ chức mã. Và thường dễ đọc hơn.

## Task 

Rewrite with arrow functions

```
function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}

ask(
  "Do you agree?",
  () => alert("You agreed."),
  () => alert("You canceled the execution.")
);
```

<a name="16"></a>
# 16. JavaScript specials

## Code structure.

Các lệnh được phân cách bởi dấy chấm phẩy.

`alert('Hello'); alert('World');`

Thông thường, xuống dòng cũng được coi là một dấu phân cách, do đó cũng sẽ làm việc:

```
alert('Hello')
alert('World')
```

Đó gọi là chèn dấu phẩy tự động. Đôi khi nó không hoạt động.

```
alert("There will be an error after this message")

[1, 2].forEach(alert)
```

Nên đặt dấu chấm phẩy ở cuối mỗi câu lệnh.

## Strict mode (chế độ nghiêm ngặt)

Để kích hoạt đầy đủ các tính năng của JavaScript hiện đại, chúng ta nên bắt đầu các Script với "use strict".

```
'use strict';

...
```

Chỉ thị có thể nằm ở đầu một script hoặc ở đầu một hàm.

Nếu không sử dụng "use strict", mọi thứ vẫn hoạt động, nhưng một số tính năng cư sử theo phong cách cổ điển, tương thích cách. Chúng tôi thường thích hành vi hiện đại.

Một số tính năng hiện đại của ngôn ngữ như classes cho phép sử dụng "use strict" ngầm.

## Variables

**Có thể khai báo bằng cách sử dụng:

`let`

`const` : Không thể thay đổi.

`var` Kiểu cũ.

**Một tên biến có thể bao gồm**

Các chữ cái và số, nhưng ký tự đầu tiên có thể không phải là một chữ số.

Ký tự `$` và `_` là bình thường, ngang bằng các chữ cái.

Ngoài ra bảng chữ cái Latinh và chữ tượng hình cũng không được phép, nhưng thường không được sử dụng.

Các biến cỏ thể lưu động - chúng có thể lưu trữ bất kỳ giá tri nào:

```
let x = 5;
x = "John";
```

**Có 7 loại dữ liệu**

`number` Cho cả dấu chấm động và số nguyên.

`string` Cho chuỗi

`boolean` cho các giá trị logic true/false.

`null` một loại với một giá trị null, có nghĩa là "trống rỗng" hoặc "không tồn tại".

`undefined` Một loại với một giá trị duy nhất không xác định, có nghĩa là "không chỉ định".

`object` and `symbol` đối với các cấu trúc dữ liệu phức tạp và các định danh duy nhất, chúng tôi đã không học được chúng.

Toán tử `typeof` trả về kiểu cho một giá trị với hai trường hợp ngoại lệ: 

```
typeof null == "object" // error in the language
typeof function(){} == "function" // functions are treated specially
```


## Interaction (sự tương tác)

Chúng tôi sử dụng các trình duyệt làm môi trường làm việc, vì vậy các chức năng UI cở bản sẽ là:

[prompt(question[, default])](#000)

Đặt một câu hỏi, và trả lại những gì mà khách truy cập hoặc không hợp lệ nếu nhận huỷ bỏ.

[confirm(question)](#00)

Đặt một câu hỏi và đề nghị chọn giữa OK và Cancel. SỰ lựa chọn  được trả về là true/false.

[alert(message)](#0000)

Xuất ra thông báo.

Tất cả các chức năng này là phương thức, họ tạm dừng việc thực hiện mã và ngăn không cho khách truy cập tương tác với trang cho đến khi anh ta trả lời.

Ví dụ:

```
let userName = prompt("Your name?", "Alice");
let isTeaWanted = confirm("Do you want some tea?");

alert( "Visitor: " + userName ); // Alice
alert( "Tea wanted: " + isTeaWanted ); // true
```


## Operators toán tử.

Javascript hỗ trợ các toán tử sau:

**Tính số học** 

Thường : `+ - * /` cũng có `%` chia lấy phần dư và `**`  cho bình phương của một số.

Nhị phân cộng `+` nối các xâu. Và nếu có một trong các toán hạng là một chuỗi - một trong những khác được chuyển thành chuỗi:

```
alert( '1' + 2 ); // '12', string
alert( 1 + '2' ); // '12', string
```


 **Assignments**

Có một công việc đơn giản: a = b và những kết hơp như a *= 2.

**Bitwise**

Các toán tử BitWise làm việc với số nguyên trên bit-level: xem các tài liệu khi cần thiết.


**Ternary**

Các nhà điều hành duy nhất với ba tham số: `cond ? result a : result b`. Nếu `cond` đúng thì trả về `result a`, nếu không thì `result b`.

**Logical operators** Toán tử logic.

AND  && và OR || thực hiện đánh giá ngắn mạch và sau đó trả lại giá trị mà nó dừng lại.

## Comparisons (so sánh)

Kiểm tra `==` cho các giá trị của các kiểu khác nhau chuyể đổi giữa chúng thành một số (ngoại trừ null và undifened bằng nhau và không có gì khác), do đó, những giá trị này bằng nhau:

```
alert( 0 == false ); // true
alert( 0 == '' ); // true
```

Các so sánh khác cung có thể chuyển thành một số.

Toán tử kiểm tra nghiêm ngặt `===` không thực iện việc chuyển đổi: các kiểu khác nhau luôn có nghĩa các giá trị khác nhau cho nó, do đó:

Giá trị null và undefined là đặc biệt: chúng bằng `===` và không bằng bất cứ giá trị nào khác.

So sánh nhiều hơn/ ít hơn so sánh character-by-character, các loại khác được chuyển đổi sang một số.

**Logical operators** Toán tử logic.

Có rất ít, như toán tử dấu phẩy.

## Loops

Chúng ta có 3 vòng lặp:

```
// 1
while (condition) {
  ...
}

// 2
do {
  ...
} while (condition);

// 3
for(let i = 0; i < 10; i++) {
  ...
}
```

Biến khai báo cho vòng lặp for được hiển thị bên trong vòng lặp. Nhưng ta cũng có thể bỏ qua cho và sử dụng lại một biển hiện có.

Chỉ thị break/continue cho phép thoát khỏi toàn bộ vòng lặp/ vòng lặp hiện tại. Sử dụng nhãn để phá vỡ các vòng lặp lồng nhau.

## The “switch” construct

Các switch được xây dựng có thể thay thế nhiều nếu kiểm tra. Nó sử dụng === để so sánh.

Ví dụ:

```
let age = prompt('Your age?', 18);

switch (age) {
  case 18:
    alert("Won't work"); // the result of prompt is a string, not a number

  case "18":
    alert("This works!");
    break;

  default:
    alert("Any value not equal to one above");
}
```

## Functions

Có 3 cách để tạo ra một hàm:

1. Hàm trong dòng mã chính.

```
function sum(a, b) {
  let result = a + b;

  return result;
}
```

2. Hàm trong ngữ cảnh của một biểu thức.

```
let sum = function(a, b) {
  let result = a + b;

  return result;
}
```

Hàm có một cái tên nhưng cái tên đó chỉ hiển thị bên trong hàm đó.

3. Hàm mũi tên.

```
// expression at the right side
let sum = (a, b) => a + b;

// or multiline syntax with { ... }, need return here:
let sum = (a, b) => {
  // ...
  return a + b;
}

// without arguments
let sayHi = () => alert("Hello");

// with a single argument
let double = n => n * 2;
```

Các hàm có thể có biến địa phương - những biến địa phương được khai báo bên trong hàm. Các biến như vậy chỉ có thể sử dụng trong hàm.

Tham số có thể có các giá trị mặc định.

Hàm luôn trả về một cái gì đó. Nếu không có câu trả lời, kết quả sẽ không được xác định.

**Function Declaration** hiển thị trong toàn bộ khối mã.

**Function Expression** tạo khi thực hiện đến
                        có thể có 1 cái tên, chỉ có thể sử dụng bên trong hàm.


## [More to come ](#15151)

Đó là một danh sách ngắn các tính năng của JavaScript. Hiện tại chúng tôi chỉ nghiên cứu những điều cơ bản. Hơn nữa trong hướng dẫn, bạn sẽ tìm thấy nhiều đặc biệt hơn và các tính năng tiên tiến của JavaScript.

<a name="b"></a>
# B.Tổng kết.
[5.Data types](#5)

[6.Type Conversions](#6)

[7.Operators](#7)

[8.Comparisons](#8)

[9.Interaction: alert, prompt, confirm](#9)

[10.Conditional operators: if, '?'](#10)

[11.Logical operators](#11)

[12.Loops: while and for](#12)

[13.The "switch" statement](#13)

[14.Functions](#14)

[15.Function expressions and arrows](#15)

[16.JavaScript specials](#16)

# B. [Tổng kết.](#b)

>----------

<a name="a"></a>
# A. Nội dung.

<a name="1"></a>
# 1. Hello, world!

## The "script" tag.

Chương tronhf JavaScript có thể được chèn vào bất kỳ vị trí nào của HTML với sự trợ giúp của thẻ `<script>`.

Ví dụ:

```
<!DOCTYPE HTML>
<html>

<body>

  <p>hùng lê</p>

  <script>
    alert( 'Hello, hùng lê!' );
  </script>

  <p>...See you again.</p>

</body>

</html>

```

Thẻ `<script>` chứa mã JavaScript được tự động thực hiện khi trình duyệt gặp thẻ.

## The modern markup.

Thẻ `<script>` có vài thuộc tính hiếm khi được sử dụng hiện nạy, nhưng chúng ta có thể tìm thấy chúng trong mã cũ:

Thuộc tính type : `<script type=...>`

Tiêu chuẩn cũ HTML4 yêu cầu một tập lệnh để có một loại. Thông thường đó là type = "text/javascript". Chuẩn HTML hiện đại giả định kiểu này theo mặc định, không có thuộc tính nào được yêu cầu.

Thuộc tính language: `<script language=...>`.

Thuộc tính này có nghĩa là hiển thị ngôn ngữ của script. Tính đến thời điểm hiện tại, thuộc tính này không còn ý nghĩa, ngôn ngữ mặc định là ngôn ngữ JavaScript. Không cần sử dụng nó.

### Bình luận trước và sau script.

Trong sách hướng dẫn người ta có thể tìm thấy nhận xét bên trong `<script>` như sau:

```
<script type="text/javascript"><!--
    ...
//--></script>

```


## Bên ngoài script.

Nếu chúng ta có rất nhiều mà JavaScript, chúng ta có thể đặt nó vào một file riêng biệt.

Script được đính kèm với HTML với thuộc tính `src`:

`<script src="/path/to/script.js"></script> `

Ở đây là đường dẫn tuyệt đối đến tập tin với tập lệnh (từ gốc trang web). Cũng có thể cung cấp một đường dẫn liên quan đến trang web hiện tại. Ví dụ: `src="script.js"` sẽ có nghĩa là một tệp "script.js" từ thư mục hiện tại.

Chúng ta cũng có thể đua ra một URL đầy đủ:

`<script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/3.2.0/lodash.js"></script>`

Đính kèm một số tập lệnh, sử dụng nhiều thẻ: 

```
<script src="/js/script1.js"></script>
<script src="/js/script2.js"></script>
…
```

**Lưu ý**

Theo nguyên tắc, chỉ có các tập lệnh đơn giản nhất được đưa vào HTML. Những tệp tin phức tạp hơn nằm trong các tệp riêng biệt.

Lợi ích của một tập tin riêng biệt là trình duyệt sẽ tải nó và sau đó lưu trữ trong bộ nhớ cache của nó.

Sau đó, các trang khác muốn có cùng một tập lệnh sẽ lấy từ bộ nhớ cache thay vì tải nó. Vì vậy, các tập tin thực sự chỉ tải về một lần.

Điều đó giúp tiết kiệm lưu lượng truy cập và làm cho các trang nhanh hơn.

**Nếu src được thiết lập, nội dung script sẽ bỏ bỏ qua.**

Thẻ `<script>` duy nhất có thể không có thuộc tính src và mã bên trong.

```
<script src="file.js">
  alert(1); // nội dung bị bỏ qua vì src đã được đặt.
</script>
```

Chúng ta phải lựa chọn một là bên ngoài `<script src="...">` hoặc `<script>` với code.

Ví dụ trên có thể chia hai phần script để hoạt động:

```
<script src="file.js"></script>
<script>
  alert(1);
</script>
```

## Summary (tóm lược).


Chúng ta có thể sử dụng thẻ script để thêm mã JavaScript vào trang.

Không yêu cầu thuộc tính type là language.

Một script trong một tập tin bên ngoài có thể được chèn với `<script src = "path / to / script.js"> </ script>.`

Có rất nhiều trình duyệt script và sự tương tác của họ với trang web. Nhưng chúng ta hãy nhớ rằng phần này của hướng dẫn này cho ngôn ngữ JavaScript, vì vậy chúng ta không nên sao lãng chính nó. Chúng tôi sẽ sử sử dụng trình duyệt như một cách để chạy Javascript, rất tiện lợi cho việc đọc trực tuyến, nhưng vẫn là một trong nhiều.

## Bài tập


### Hiển thị cảnh báo.
Create a page that shows a message “I’m JavaScript!”.

```
<!DOCTYPE html>
<html>
<head>
    <title>huyen tran</title>
</head>
<body>

<b>hung le</b>

<script> alert('I’m JavaScript!'); </script>

</body>
</html>

```

### Hiển thị cảnh báo với một tệp bên ngoài


```
<!DOCTYPE html>
<html>
<head>
    <title>huyen tran</title>
</head>
<body>

<b>hung le</b>
<script src="qưe.js"></script>
<script> alert('I’m JavaScript!'); </script>

</body>
</html>
```

**JS**

```
let str = "Hello";
let str2 = 'Single quotes are ok too';
let phrase = `can embed ${str}`;
alert(phrase);
```


<a name="2"></a>
# 2. Code structure

Đầu tiên cần nghiên cứu là các khối xây dựng mã.

## Statements

Các câu lệnh là cấu trúc cú pháp và các lệnh thực hiện các hành động.

Chúng tôi đã nhìn thấy thông báo cảnh báo ('hello, world!'), với hiển thị thông báo.

Chúng ta có thể có nhiều câu lệnh trong mã như chúng ta muốn. Một tuyên bố có thể được tách ra bằng một dấu chấm phẩy.

Ví dụ ở đây chúng tôi chia thành hai thông điệp: 

`alert('Hello'); alert('World');`

Thông thường mỗi câu lệnh được viết trên một dòng riêng biệt - do đó mã trở nên dễ đọc hơn:

```
alert('Hello');
alert('World');
```

## Semicolons (dấu chấm phẩy)

Một dấu chấm phẩy có thể được bỏ qua trong hầu hết các trường hợp khi ngắt dòng tồn tại.

Điều này cũng sẽ làm việc: 

```
alert('Hello')
alert('World')
```

Ở đây JavaScript giải nghĩa ngắt dòng như là một dấu chấm phẩy "ẩn". Đó cũng được gọi là chèn dấu chấm phẩy tự động.

**Trong hầu hết các trường hợp một dòng mới bao hàm một dáu chấm phẩy. Nhưng "trong hầu hết các trường hợp" không có nghĩa là "luôn luôn".!**

Có những trường hợp khi một dòng mới không có nghĩa là một dấu chấm phẩy, ví dụ:

```
alert(3 +
1
+ 2); //result 6
```

Mã đầu ra 6, vì JavaScript không chèn dấu phẩy ở đây. Rõ ràng là nếu dòng kết thúc bằng một dấu cộng "+" thì đó là một biểu hiện không đầy đủ, không cần dấu chấm phẩy. Và trong trường hợp này hoạt động như dự định.

**Nhưng có những tình huống mà JavaScript không thành công để giả sử một dấu chấm phẩy nơi nó thực sự cần thiết.**

Lỗi trong các tình huống như vậy là khá khó để tìm và sữa chữa.

Ví dụ:

```
alert("There will be an error")  //thiếu dấu chấm phẩy.

[1, 2].forEach(alert)
```

Ở đây thiếu một dấu chấm phẩy mà nó sẽ bị lỗi

Nếu thêm dấu chấm phẩy thì mọi chuyện bình thường:

```
alert("All fine now");

[1, 2].forEach(alert)
```

Lỗi trong biến thể không có dấu chấm phẩy xãy ra vì JavaScript không ngụ ý một dấu chấm phẩy trước ngoặc vuông [...].

Vì vậy, bời vì chèn dấu chấm phẩy được tự động chèn vào, mã trong ví dụ đầu tiên được coi là một câu lệnh, đó là cách mà một công cụ nhìn thấy nó:

`alert("There will be an error")[1, 2].forEach(alert)`

Nhưng không cần phải có hai tuyên bố riêng biệt, không phỉa là một báo cáo riêng lẽ. Việc hợp nhất trong trường hợp này chỉ là sai, vì thế là lỗi. Có những tình huống khác khi điều đó sãy ra.

Bạn nên đặt dấy chấm phẩy giữa các câu lệnh ngay khi chúng được phân cách bằng một dòng mới. Quy tắc này được cộng đồng chấp nhận rộng rãi. Chúng ta hãy lưu ý một lần nữa- có thể bỏ dấu chấm phẩy bất kể thời gian. Nhưng nó an toàn hơn, đặc biệt là cho người bắt đầu- để đặt chúng.

## Comments

Thời gian trôi đi, chương trinh ngày càng phức tạp. Nó sẽ trở thành cần thiết để thêm ý kiến mô tả những gì xãy ra và tại sao. Nhận xét có thể được đưa vào bất kì nơi nào của kịch bản. Họ không ảnh hưởng đến việc thực hiện, bởi vì động cơ chỉ cần bỏ qua chúng.

**Một dòng nhận xét bắt đầu với hai dấu gạch chéo phía trước "//"**

Ví dụ:

```
// This comment occupies a line of its own
alert('Hello');

alert('World'); // This comment follows the statement
```

**Nhận xet nhiều dòng**

```
/* An example with two messages.
This is a multiline comment.
*/
alert('Hello');
alert('World');
```

**Không được để nhận xét lồng vào nhau!!!**

<a name="3"></a>
# 3.The modern mode, "use strict".

Trong một thời gian dài JavaScript đã được phát triển mà không có vấn đề tương thích. Các tính năng mới đã được thêm vào ngôn ngữ, nhưng chức năng cũ không thay đổi.

Điều đó có lợi ích không bao giờ phá vỡ các mã hiện có. Nhưng nhược điểm là bất kỳ sai lầm hoặc một quyết định không hoàn hảo của người sáng tạo đã bị măc kẹt trong ngôn ngữ mãi mãi.

Nó đã được cho đến năm 2009 khi SCMAScript 5 (ES5) xuất hiện. Nó bổ xung các tính năng mới cho ngôn ngữ và sữa đổi một số các tính năng hiện có. Để giữ mã cũ hoạt động, hầu hết các sữa đổi đề bị tắt theo mặc định. Người ta cần phải cho phép họ rõ ràng với một chỉ thị đặc biệt "use strict".

**use strict**

Chỉ thị giống như một chuỗi: "use strict" hoặc 'use strict'. Khi nó nằm trên đỉnh của kịch bản, sau đó toàn bộ kịch bản hoạt động theo cách hiện đại.

Ví dụ:

```
"use strict";

// mã này hoạt động theo cách hiện đại.
...

```

Nhìn về phía trước chúng ta chỉ cần lưu ý rằng "use strict" cỏ thể đặt ở đầu của một số chức năng (hầu hết các loại chức năng) thay vì toàn bộ kịch bản. Sau đó chế độ nghiêm ngặt được bật trong chức năng đó. Nhưng thường mọi người sử dụng nó cho toàn bộ stript.

**Đảm bảo rằng use strict là ở đầu.**

Hãy đảm bảo rằng "use strict" là ở đầu, nếu không chế độ nghiêm ngặt có thể không được kích hoạt.

Không có "use strict" ở đây:

```
alert("some code");
// "use strict" ở đây bị bỏ qua, phải đặt trên đầu trang.

"use strict";

// strict mode không được kích hoạt
```

Chỉ có nhận xét xuất hiện ở trên "use strict".

**Không có cách nào để huỷ bỏ use strict**.

Không có chỉ thị "no use strict" hoặc giống nhau, mà có thể trở lại hành vi cũ.

Một khi vào use strict, không có trở lại.

## Always "use strict" (luôn sử dụng use strict)

Sự khác biệt của chế độ "use strict" so với chế độ mặc định vẫn dduojcwj bảo vệ.

Trong thời điểm hiện tại, nó đủ để biết vế nó nói chung:
1. Use strict sẽ chuyển công cụ sang chế độ "modern", thay đổi hành vi của một số tính năng được tích hợp.
2. Chế độ strict  được kích hoạt bởi "use strict" ở trên cùng. Ngoài ra có một số tính năng ngôn ngữ như "classes" và "modules" cho phép chế độ strict tự động.
3. Chế độ strict được hỗ trợ bởi tất cả các trình duyệt hiện đại.
4. Luôn luôn đề nghị bắt đầu các tập lệnh với "use strict". Tất cả các ví dụ trong hướng dẫn này giả sử như vậy, trừ khi quy định khác.

<a name="4"></a>
# 4.Variables.

Hầu hết thời gian, một kịch bản cần làm việc với thông tin. Nếu đó là một của hàng trực tuyến - đó sẽ là hàng hoá và giỏ hàng. Nếu đó là cuộc trò chuyện- người dùng, tin nhắn....

Các biến được sử dụng để lưu trữ thông tin.

## A variable

Một biến là một "name storage" cho dữ liệu. Chúng ta có thể sử dụng các biến để lưu trữ goodies, thăm và các dữ liệu khác. 

Để tạo một biến Javascript, chúng ta cần sử dụng từ khoá `let`.

Ví dụ: `let message;`

Chúng ta có thể đưa một số dữ liệu vào nó bằng các sử dụng toán tử gán `=` :

```
let message;

message = 'Hello'; // lưu chuỗi
```

Chuỗi bây giờ được lưu vào vùng nhớ kết hợp tên biến. Chúng ta có thể truy cập nó bằng cách sử dụng tên biến:

```
let message;
message = 'Hello!';

alert(message); // hiển thị nội dung biến
```

Để ngắn gọn chúng ta có thể hợp nhất khao báo và gán thành một dòng đơn:

```
let message = 'Hello!'; // define the variable and assign the value

alert(message); // Hello!
```

Chúng ta cũng có thể khai báo nhiều biến trên một dòng:

```
let user = 'John', age = 25, message = 'Hello';
```

Điều đó có vã ngắn hơn, nhưng nó không được khuyến cáo. Để có thể dễ đọc hơn, vui lòng sử dụng một dòng một biến.

```
let user = 'John';
let age = 25;
let message = 'Hello';
```

**var thay vì let**

Trong các tập lệnh cũ hơn bạn cũng có thể tìm thấy từ khoá khác: var thay vì let.

`var message = 'Hello';`

Từ khoá var gần giống như let. Nó cũng tuyên bố một biến, nhưng nó hơi khác nhau,"old-school" thời trang.

## a real-life analogy (một phép so sánh thực tế)

Chúng ta cũng có thể khai báo hai biế và sao chép dữ liệu từ một trong các biến khác.

```
let hello = 'Hello world!';

let message;

// copy 'Hello world' from hello into message
message = hello;

// bây giờ hai biến cùng một kiểu dữ liệu
alert(hello); // Hello world!
alert(message); // Hello world!
```

## Variable naming

Có hai hạn chế đối với một tên biến trong JavaScript:

1.Tên chứa chữ cái, chữ số, ký hiệu $ và __ .

2. Ký tự đầu tiên không phải là chữ số.

Các tên hợp lệ :

```
let userName;
let test123;
```

Khi tên chứa nhiều từ, camelCase thường được sử dụng. Đó là: các từ đi từng cái một, mỗi từ bắt đầu bằng chữ cái hoa: myVeryLongName.

Những tên hợp lệ:

```
let $ = 1; // declared a variable with the name "$"
let _ = 2; // and now a variable with the name "_"

alert($ + _); // 3
```

Những tên không hợp lệ:

```
let 1a; // không được bắt đầu bằng số.

let my-name; // a hyphen không được có dấu - trong tên.
```

Tên biến có phân biệt hoa thường.

Tên biến có thể sử dụng bất ký ngôn ngữ nào

Tên biến không được trùng với từ khoá.

```
let let = 5; // 
let return = 5; //
```

**Một nhiệm vụ mà không có use strict**

```
// note: không sử dụng use strict trong ví dụ

num = 5; // biến num được khởi tạo nếu không tồn tại

alert(num); // 5
```

```
"use strict";

num = 5; // biến num không được khởi tạo.
```

## Constant (hằng số)

Để khai báo biến (không thay đổi) liên tục, ta sử dụng `const` thay vì `let`:

`const myBirthday = '18.04.1982';`

Biến được khai báo sử dụng `const` là các hằng số. Họ không thể thay đổi. Một nỗ lực để làm điểu đó sẽ gây ra một lỗi:

```const myBirthday = '18.04.1982';

myBirthday = '01.01.2001'; // error, không thể chỉnh lại hằng số!
```

Khi một lập trình viên chắc chắn rằng biến không bao giờ nên thay đổi, ông có thể sử dụng `const` để đảm bảo nó, và cũng để rõ ràng cho thấy rằng thực tế cho tất cả mọi người.

## Uppercase constants (hằng số trên)

```
const COLOR_RED = "#F00";
const COLOR_GREEN = "#0F0";
const COLOR_BLUE = "#00F";
const COLOR_ORANGE = "#FF7F00";

// ...when we need to pick a color
let color = COLOR_ORANGE;
alert(color); // #FF7F00
```

## Name things right (đặt tên đúng)

Hãy đặt tên biến hợp lý. Dành thời gian để suy nghĩ nếu cần thiết.

Đặt tên biến là một trong những kỹ năng quan trọng và phức tạp nhất trong lập trình. Một cáu nhìn nhanh về các tên biến có thể tiết lộ mã nào được viết bởi người mới bắt đầu và một người phát triển có kinh nghệm.

Trong một dự án thưc, phần lớn thời gian dành cho việc sữa đổi và mở rộng cơ sở mã hiện tại, hơn là viết một cái gì đó hoàn toàn tách biệt khởi đầu. Và khi chúng tôi trở lại mã sau một thời giam làm điều gì đó khác, thì dễ dàng hơn nhiều để tìm thông tin được gắn nhãn tốt. Hay nói cách khác, khi các biến cso tên tốt.

## Summary (tóm lược)

Chúng ta có thể khai báo các biến để lưu trữ dũ liệu. Điều đó có thể được thực hiện bằng cách sử dụng var hoặc let hoặc const.

## Task

**Working with variables**

```
<!DOCTYPE html>
<html>
<head>
    <title>huyen tran</title>
</head>
<body>

<b>hung le</b>
<script src="qưe.js"></script>
</body>
</html>
```

```
let admin;
let name;
name = 'John';
admin = name;
alert(admin);
```

**Giving the right name**

`let ourPlanet;` tên biến hành tinh của chúng ta.

`let newCurrent;` tên biến khách hàng hiện tại.

<a name="5"></a>
# 5. Data types

Một biến trong JavaScript có thể chứ bất kỳ dữ liệu nào. Một biến có thể tạo một thời điểm là một chuỗi và sau đó nhận được một giá trị số:

```
// no error
let message = "hello";
message = 123456;
```

## A number

Loại số dùng cho cả số nguyên và số dấu chấm động. Có nhiều hoạt động cho số, ví dụ: Nhân *, chia /, cộng +, trừ - và vân vân. Bên cạnh các số thường xuyên, còn có cái gọi là "giá trị số đặc biệt" thuộc loại đó: Infinity, -Infinity và NaN.

**Infinity**

`alert( 1 / 0 ); // Infinity`

`alert( Infinity ); // Infinity`

**NaN**

`alert( "not a number" / 2 + 5 ); // NaN`

Nếu có NaN một nơi nào đó trong một biểu thức toán học, nó lan truyền toàn bộ kêt quả.

**Hoạt động toán học an toàn**

Thực hành toán học là an toàn trong JavaScript. Chúng ta có thể làm bất cứ điều gì: chia cho số không, xử lý chuỗi không phải số như số, vv

Script sẽ không bao giờ dừng lại với một lỗi chết người ("chết"). Trong tồi tệ nhất, chúng tôi sẽ nhận được NaN như là kết quả.

## A String

Một chuỗi trong JavaScript phải dduocj trích dẫn.

```
let str = "Hello";
let str2 = 'Single quotes are ok too';
let phrase = `can embed ${str}`;
```

Backticks là mở rộn chức năng báo giá. Chúng cho phép nhúng biến vào biểu thức vafp một chuỗi bằng cách gói chúng trong ${...}:

```
let name = "John";

// embed a variable
alert( `Hello, ${name}!` ); // Hello, John!

// embed an expression
alert( `the result is ${1 + 2}` ); // the result is 3
```

## A boolean (logical type)

là kiểu gồm hai giá trị là true và false.

```
let nameFieldChecked = true; // yes, name field is checked
let ageFieldChecked = false; // no, age field is not checked
```

```
let isGreater = 4 > 1;

alert( isGreater ); // true (the comparison result is "yes")
```

## Giá trị Null

`let age = null;`

## The “undefined” value (giá trị không xác định)

Giống như null

Ý nghĩa là giá trị không được gán.

```
let x;

alert(x); // shows "undefined"
```

Về mặt kỹ thuật có thể gán bất kỳ biến nào thành undefined:

```
let x = 123;

x = undefined;

alert(x); // "undefined"
```

## Objects and Symbols (đồi tượng và ký hiệu)

## The typeof operator (toán tử typeof)

Toán từ typeof trả về kiểu đối số. Điều này rất hữu ích khi chúng tôi muốn xử lý các giá trị khác nhau theo kiểu khác nhau hoặc chỉ muốn thực hiện kiểm tra nhanh.

Nó hỗ trợ hai dạng cú pháp

`tyoeof x;`

`typeof(x);`



## Summary

`number` cho bất kỳ dạng nào: số nguyên hoặc số có dấu chấm động.

`string` cho một chuỗi. Một chuỗi có thể có một hoặc nhiều ký tự, không có loại ký tự đơn lẻ.


`boolean` for `true/false`

`null` cho các giá trị không xác định - một loại đôc lập có một giá trị null.

`undefined` cho giá trị chưa được gán - một loại đọc lập có một giá trị duy nhất chưa được xác định.

`object` cho các cấu trúc dữ liệu phức tạp hơn.

`symbol` cho các định danh duy nhất.

## Task

```
let name = "Ilya";

alert( `hello ${1}` ); // 1

alert( `hello ${"name"}` ); // name

alert( `hello ${name}` ); // Ilya
```

<a name="6"></a>
# 6. Type Conversions.(chuyển đổi loại)

## ToString

```
let value = true;
alert(typeof value); // boolean

value = String(value); // now value is a string "true"
alert(typeof value); // string
```

Việc chuyển đổi chuỗi rõ ràng là rõ ràng. Một false trở thành "false", null trở thành "null" ...

## ToNumber

Chuyển đổi số sẽ xảy ra trong các hàm và biểu thức toán học tự động. Ví dụ, khi phân chia / được áp dụng cho các số không:


`alert( "6" / "2" ); // 3, strings are converted to numbers`

```
let str = "123";
alert(typeof str); // string

let num = Number(str); // becomes a number 123

alert(typeof num); // number
```

Việc chuyển đổi rõ ràng thường được yêu cầu khi chúng ta đọc một giá trị từ một nguồn dựa trên chuỗi như một mẫu văn bản, nhưng chúng tôi mong đợi một số được nhập.

Nếu chuỗi không phải là một số hợp lệ, kết quả của việc chuyển đổi như vậy là NaN, ví dụ:

```
let age = Number("an arbitrary string instead of a number");

alert(age); // NaN, conversion failed
```

Quy tắc chuyển đổi số:

<img src="http://sv1.upsieutoc.com/2017/07/05/153110.png">

```
alert( Number("   123   ") ); // 123
alert( Number("123z") );      // NaN (error reading a number at "z")
alert( Number(true) );        // 1
alert( Number(false) );       // 0
```

Xin lưu ý rằng null và undefined cư xử một cách khác nhau ở đây: null trở thành một số không, trong khi undefined trở thành NaN.

**Thêm '+' nối các xâu**

```
alert( 1 + '2' ); // '12' (string to the right)
alert( '1' + 2 ); // '12' (string to the left)
```

Điều đó chỉ xảy ra khi một trong những đối số là một chuỗi. Nếu không, các giá trị được chuyển thành số.

## ToBoolean

```
alert( Boolean(1) ); // true
alert( Boolean(0) ); // false

alert( Boolean("hello") ); // true
alert( Boolean("") ); // false
```

Boolean chuyển đổi là một trong những đơn giản nhất.

Nó sẽ xảy ra trong các hoạt động hợp lý (sau đó chúng ta sẽ đáp ứng các bài kiểm tra điều kiện và các loại khác của chúng), nhưng cũng có thể được thực hiện bằng tay với các cuộc gọi của Boolean (giá trị).

Quy tắc chuyển đổi:

Các giá trị vô nghĩa "trống rỗng", như 0, một chuỗi rỗng, null, undefined và NaN trở nên sai.

Các giá trị khác trở thành sự thật

Xin lưu ý: chuỗi với số không "0" là đúng

```
alert( Boolean("0") ); // true
alert( Boolean(" ") ); // spaces, also true (any non-empty string is true)
```

## Task

```
"" + 1 + 0 //10
"" - 1 + 0 // -1
true + false // 1
6 / "3" // 2
"2" * "3" // 6
4 + 5 + "px" // 9px
"$" + 4 + 5 // $45
"4" - 2 // 2
"4px" - 2 //NaN
7 / 0 // Infinity
"  -9\n" + 5 // 9 5
"  -9\n" - 5 // -14
null + 1 // 1
undefined + 1 // NaN
```

<a name="7"></a>
# 7.Operators (nhà khai thác)

## Thuật ngữ: "unary", "binary", "operand"

```
let x = 1;

x = -x;
alert( x ); // -1, unary negation was applied
```


```
let x = 1, y = 3;
alert( y - x ); // 2, binary minus subtracts values
```

## Strings concatenation, binary + (Ghép nối, nhị phân +)

Nối chuỗi:

```
let s = "my" + "string";
alert(s); // mystring
```

Nối chuỗi số:

```
alert( '1' + 2 ); // "12"
alert( 2 + '1' ); // "21"
```

Ví dụ phép trừ và phép chia:

```
alert( 2 - '1' ); // 1
alert( '6' / '2' ); // 3
```

## Numeric conversion, unary + (chuyển đổi số, unary +)

```
// không ảnh hưởng đến số.
let x = 1;
alert( +x ); // 1

let y = -2;
alert( +y ); // -2

// Chuyển đổi số không
alert( +true ); // 1
alert( +"" );   // 0
```

Nó thực sự làm giống Num(...) nhưng ngắn hơn.

```
let apples = "2";
let oranges = "3";

alert( apples + oranges ); // "23", các nhị phân cộng với nối chuỗi
```

Nếu chúng ta muốn đối xử với chúng như số, sau đó chúng ta có thể chuyển đổi và sau đó tổng hợp:

```
let apples = "2";
let oranges = "3";

// các giá trị được chuyển đổi thành số sau khi cộng nhị phân
alert( +apples + +oranges ); // 5

// biến thể dài hơn
// alert( Number(apples) + Number(oranges) ); // 5
```

## Operators precedence (toán tử ưu tiên)

Nếu một biểu thức có nhiều toán tử, thứ tự thực hiện được xác định bởi sự ưu tiên của chúng, hoặc, nói cách khác, có một trật tự ưu tiên ẩn trong các toán tử.

Nếu sự ưu tiên là như nhau - lệnh thực hiện là từ trái sang phải.

Trích dẫn bảng ưu tiên:

<img src="http://sv1.upsieutoc.com/2017/07/06/2.png">

## Assignment (chuyển nhượng)

```
let x = 2 * 2 + 1;

alert( x ); // 5
```

Có thể phân công chuỗi:

```
let a, b, c;

a = b = c = 2 + 2;

alert( a ); // 4
alert( b ); // 4
alert( c ); // 4
```

```
let a = 1;
let b = 2;

let c = 3 - (a = b + 1);

alert( a ); // 3
alert( c ); // 0
```

Trong ví dụ trên, kết quả của (a = b + 1) là giá trị được gán cho a (nghĩa là 3). Sau đó nó được sử dụng để trừ từ 3.

## Remainder % (chia phền dư)

```
alert( 5 % 2 ); // dư 1
alert( 8 % 3 ); // dư 2
alert( 6 % 3 ); // dư 0
```

## Exponentiation ** (luỹ thừa)

```
alert( 2 ** 2 ); // 4  (2 * 2)
alert( 2 ** 3 ); // 8  (2 * 2 * 2)
alert( 2 ** 4 ); // 16 (2 * 2 * 2 * 2)
```

```
alert( 4 ** (1/2) ); // 2 
alert( 8 ** (1/3) ); // 2
```

##  Increment/decrement (tằng/giảm)

**Incrediment** `++` tăng 1 đơn vị.

```
let counter = 2;
counter++;      
alert( counter ); // 3
```

**Decrement** `--` giảm một đơn vị.

```
let counter = 2;
counter--;     
alert( counter ); // 1
```

## Bitwise operators (toán tử bitwise)

AND ( & )

OR ( | )

XOR ( ^ )

NOT ( ~ )

LEFT SHIFT ( << )

RIGHT SHIFT ( >> )

ZERO-FILL RIGHT SHIFT ( >>> )

## Modify-in-place

```
let n = 2;
n = n + 5;
n = n * 2;
```

```
let n = 2;
n += 5; // now n=7 (same as n = n + 5)
n *= 2; // now n=14 (same as n = n * 2)

alert( n ); // 14
```

```
let n = 2;

n *= 3 + 5;

alert( n ); // 16
```

## Comma

```
let a = (1+2, 3+4);

alert( a ); // 7 (the result of 3+4)
```

Ở đây, biểu thức đầu tiên bị ném đi, sau đó 3+4 được đánh giá và trả về kết quả.

## Task

```
let a = 1, b = 1;

let c = ++a; // 2
let d = b++; // 1
```

```
let a = 2;

let x = 1 + (a *= 2);

// a=4
// x = 5
```

<a name="8"></a>
# 8. Comparisons (so sánh)
 
 Các toán tử so sánh:
  `> <` lớn, bé

  `>= , <=` lớn hơn hoặc bằng, bé hơn hoặc bằng.

  `==` toán tử so sánh

  `!=` phủ định phép bằng

  ## Boolean is the result (boolean là kết quả)

  ```
alert( 2 > 1 );  // true (correct)
alert( 2 == 1 ); // false (wrong)
alert( 2 != 1 ); // true (correct)
  ```


```
let result = 5 > 4; // gán kết quả cho sụ so sánh.
alert( result ); // true
```

## String comparison (so sánh chuỗi)

```
alert( 'Z' > 'A' ); // true
alert( 'Glow' > 'Glee' ); // true
alert( 'Bee' > 'Be' ); // true
```

Thuật toán để so sánh chuỗi đơn giản.

1. So sánh ký tự đầu tiên của hai dãy.
2. Nếu đầu tiên lè lớn hơn (hoặc ít hơn), sau đó chuỗi đầu tiên lơn hơn (hoặc ít hơn) thứ hai. Đã được thực hiện.
3. Nếu không, nếu các ký tự đầu tiên bằng nhau, so sánh các ký tự thứ hai theo cùng một cách.
4.  Lặp lại cho đến khi kế thúc chuỗi bất kỳ.
5.  Nếu hai chuỗi kết thúc cùng một lúc thì hai chuỗi đều bằng nhau. Nếu không thì chuỗi dài hơn lớn hơn.

## Comparison of different types (so sánh các loại khác nhau)

Khi so sánh các giá trị thuộc về các loại khác nhau, chúng được chuyển đổi thành các con số.

```
alert( '2' > 1 ); // true, chuỗi 2 được chuyển thành số 2
alert( '01' == 1 ); // true, chuỗi 01 được đổi thành số 1.

```

```
alert( true == 1 ); // true
alert( false == 0 ); // true
```

```
let a = 0;
alert( Boolean(a) ); // false

let b = "0";
alert( Boolean(b) ); // true

alert(a == b); // true!
```

## Strict equality (bình đẳng nghiêm ngặt)

`alert( '' == false ); // true` Một chuỗi rỗng được chuyển thành số 0.


**Kiểm tra sự bằng nhau mà không chuyển đổi kiểu**

`alert( 0 === false ); // false, bởi vì hai loại khác nhau`

## Comparison with null and undefined (so sánh với null và undefined)

**Đối với kiểm tra nghiêm ngặt ====**

`alert( null === undefined ); // false`

**Đối với kiểm tra không nghiêm ngặt**

`lert( null == undefined ); // true`

**Đối với toán học và so sánh khác <> <=> =**

Các giá trị null / undefined được chuyển thành một số: null trở thành 0, trong khi undefined trở thành NaN.


## Strange result: null vs 0 (kết quả lạ: null và 0)

```
alert( null > 0 );  // (1) false
alert( null == 0 ); // (2) false
alert( null >= 0 ); // (3) true
```

## An incomparable undefined (một undefined không xác định)


```
alert( undefined > 0 ); // false (1)
alert( undefined < 0 ); // false (2)
alert( undefined == 0 ); // false (3)
```

## Summary (tóm lược)

Các toán tử so sánh mang lại một giá tị logic.

Các chuỗi trên được so sánh theo từng chữ trong trật tự từ điển.

Khi so sánh các giá trị của các loại khác nhau, chúng sẽ được chuyển đổi thành các con số (với việc loại trừ kiểm tra tính bình đẳng nghiêm ngặt).

Các giá trị null và undefined bằng `==` và không bằng bất kỳ giá trị nào khác.

Hãy cẩn thận khi sử dụng so sánh như `>` hoặc `<` với các biến mà thỉnh thoảng có thể được null/undefined. Làm cmootj kiểm tra riêng biệt cho null/ undifened là một ý tưởng tốt.

## Task

```
5 > 4 // true
"apple" > "pineapple" // fale
"2" > "12" // true
undefined == null // true
undefined === null false
null == "\n0\n" // false
null === +"\n0\n" // false
```


<a name="9"></a>
# 9. Interaction: alert, prompt, confirm (tương tác: alert, prompt, confirm)

## alert

`alert(message);`

`alert("Hello");`

## prompt

`result = prompt(title[, default]);`

Nó cho thấy một cửa sổ modal với một tin nhắn văn bản, một trường cho khách truy cập các nút OK / CANCEL.

**title**

Văn bản hiển thị cho khách truy cập.

**dafault**

Một tham sso thứ hai tuỳ chọn, giá trị ban đầu cho trường đầu vào.

```
let age = prompt('How old are you?', 100);

alert(`You are ${age} years old!`); // You are 100 years old!
```

<img src="http://sv1.upsieutoc.com/2017/07/06/30c332.png">

<img src="http://sv1.upsieutoc.com/2017/07/06/427691.png">

## confirm

`result = confirm(question);`

Chức năng xác nhận cho thấy một cửa sổ modal vơi một câu hỏi và hai nút: OK và CANCEL.

Kết quả là đúng nếu OK được ấn và sai nếu không.

```
let isBoss = confirm("Are you the boss?");

alert( isBoss ); // true if OK is pressed
```


## Summary (tóm lược)

**alert** show thông báo

**prompt** Hiển thị thông báo yêu cầu người dùng nhập văn bản. Nó trả về văn bản hoặc, nếu CANCEL hoặc Esc được nhấp vào, tất cả các trình duyệt ngoại trừ Safari trả về null.

**confirm** Hiển thị một thông báo và chờ người dùng nhấn OK hoặc CANCEL. Nó trả về true cho OK và false cho CANCEL/Esc.

## Task

```
<!DOCTYPE html>
<html>
<head>
    <title>huyen tran</title>
</head>
<body>

<b>hung le</b>
<script src="qưe.js"></script>
</body>
</html>
```

```
let test = prompt("Tên của bạn...");

alert(test);
```

<img src="http://sv1.upsieutoc.com/2017/07/06/16c63f.png">

<img src="http://sv1.upsieutoc.com/2017/07/06/2c7016.png">

<a name="10"></a>
# 10. Conditional operators: if, '?'.



Đôi khi (sometimes) chúng ta cần thực hiện (perform) các hành động (action) khác nhau dựa trên một điều kiện (condition).

 Có một toán tử IF cho điểu đó và cũng là toán tử "question mark" : "?" Để đánh giá có điều kiện.

 ## The "if" operator

 ```
let year = prompt('In which year was ECMAScript-2015 specification published?', '');

if (year == 2015) alert( 'You are right!' );
 ```


## Boolean conversion (chuyển đổi boolean)

Một số 0, một chuỗi rỗng "", null, undefined và NaN trở nên sai. Do đó chúng được gọi là giá trị "giả tạo".

Các giá trị khác trở thành sự thật, vì vậy chúng trở thành chân lý. (truthy)


## The "else" clause (mệnh đề else)

```
let year = prompt('In which year was ECMAScript-2015 specification published?', '');

if (year == 2015) {
  alert( 'You guessed it right!' );
} else {
  alert( 'How can you be so wrong?' ); // any value except 2015
```

## Several conditions: “else if” (Mệnh đề "else if")

```
let year = prompt('In which year was ECMAScript-2015 specification published?', '');

if (year < 2015) {
  alert( 'Too early...' );
} else if (year > 2015) {
  alert( 'Too late' );
} else {
  alert( 'Exactly!' );
}
```

## Ternary operator ‘?’

Đôi khi chúng ta cần gán một biến phụ thuộc vào điều kiện.

```
let accessAllowed;
let age = prompt('How old are you?', '');

if (age > 18) {
  accessAllowed = true;
} else {
  accessAllowed = false;
}

alert(accessAllowed);
```

Toán tử này được đại diện bởi một dấu chấm hỏi "?" thuật ngữ chính thức "ternary" có nghĩa là toán tử có 3 toán hạng. Nó thực sự là một trong những nhà điều hành duy nhất trong JavaScript mà có rất nhiều.

Cú pháp là:

`let result = condition ? value1 : value2`

Nếu đúng thì trả về giá trị 1, nếu sai thì trả về giá trị 2.

VD:
`let accessAllowed = (age > 18) ? true : false;`

## Multiple '?'

Một dãy dấu chấm hỏi "?" Các toán tử cho phép trả lại một giá trị tuỳ thuộc vào nhiều điều kiện.

```
let age = prompt('age?', 18);

let message = (age < 3) ? 'Hi, baby!' :
  (age < 18) ? 'Hello!' :
  (age < 100) ? 'Greetings!' :
  'What an unusual age!';

alert( message );
```

Nó là một chuỗi các kiểm tra thông thường.


## Non-traditional use of ‘?’ (Không truyền thông bởi "?")

Đôi khi dấu hỏi '?' được sử dụng như một sự thay thế nếu:

```
let company = prompt('Which company created JavaScript?', '');

(company == 'Netscape') ?
   alert('Right!') : alert('Wrong.');
```

**Không nên sử dụng toán tử đánh dấu câu hỏi theo cách này.**

```
let company = prompt('Which company created JavaScript?', '');

if (company == 'Netscape') {
  alert('Right!');
} else {
  alert('Wrong.');
```

## Task

**Show the sign**

```
let hung = prompt ("Nhập vào một số: ",'number');

if(hung > 1)
{
    alert(1);
}
else if (hung < 1) 
{
    alert(-1);
}
else 
{
    alert(0);
}
```

**Check the login**

```
let hung = prompt ("Who is there ?");

if(hung == "Cancel")
{
    alert("Canceled");
}
else if (hung == "Other") 
{
    alert("I don't know you.");
}
else if(hung == "Admin")
{
    let le = prompt ("Password?");

    if(le == "Cancel")
    {
        alert("Canceled");
    }
    else if (le == "Other") 
    {
        alert("Wrong password");
    }
    else if( le == "TheMaster")
        {
            alert("Welcome!");
        }
}
```

**Rewrite 'if' into '?'**

```
const a = 1;
const b = 1;

(a+b < 4) ? alert('Below') : alert('Over');
```

**Rewrite 'if..else' into '?'**

```
let message;

let login = prompt('nhập: ');

(login == 'Employee') ? message = 'Hello' : (login == 'Director') ? message = 'Greetings' : (login == '') ? message = 'No login' : '';

alert (message);
```

<a name="11"></a>
# 11.Logical operators (Toán tử logic )

## || (OR)

`result = a || b;`

Ví dụ:

```
alert( true || true );   // true
alert( false || true );  // true
alert( true || false );  // true
alert( false || false ); // false
```

## OR seeks the first truthy value ( Tìm giá trị xác thực đầu tiên.)

`result = value1 || value2 || value3;` so sánh từ trái quá và lấy giá trị đúng.

```
alert( 1 || 0 ); // 1 (1 is truthy)
alert( true || 'no matter what' ); // (true is truthy)

alert( null || 1 ); // 1 (1 is the first truthy value)
alert( null || 0 || 1 ); // 1 (the first truthy value)
alert( undefined || null || 0 ); // 0 (all falsy, returns the last value)
```

## && (AND)

`result = a && b;`

```
alert( true && true );   // true
alert( false && true );  // false
alert( true && false );  // false
alert( false && false ); // false
```

```
let hour = 12;
let minute = 30;

if (hour == 12 && minute == 30) {
  alert( 'Time is 12:30' );
}
```


## AND seeks the first falsy value

`result = value1 && value2 && value3;`

Hoạt động:

Đánh dấu toán hạng từ trái sang phải.

Đối với mỗi giá trị chuyển nó thành một boolean. Nếu kết quả sai, dừng lại và trả về giá trị ban đầu.

Nếu giá trị kết thúc, trả về giá trị cuối cùng.

**Thứ tự của toán tử AND && là cao hơn OR ||, do đó nó được thực thi trước OR.

`alert( 5 || 1 && 0 ); // 5`

## ! (NOT)

`result = !value;`

Chuyển đổi toán hạng thành kiểu boolean: true / false.

Trả về giá trị nghịch đảo.

```
alert( !true ); // false
alert( !0 ); // true
```

Một đôi NOT !! đôi khi được sử dụng để chuyển đổi một giá trị sang kiểu boolean:

```
alert( !!"non-empty string" ); // true
alert( !!null ); // false
```

Tương tự:

```
alert( Boolean("non-empty string") ); // true
alert( Boolean(null) ); // false
```

## Task

What the code below is going to output?

`alert( null || 2 || undefined ); // 2`

What's the result of OR'ed alerts?

`alert( alert(1) || 2 || alert(3) ); //1  2`

What is the result of AND?

`alert( 1 && null && 2 ); // null`

What is the result of AND'ed alerts?

`alert( alert(1) && alert(2) ); // 1 undefined`

The result of OR AND OR

`alert( null || 2 && 3 || 4 ); //3`

Check the range between

`if (age >= 14 && age <= 90)`

Check the range outside

`if (!(age >= 14 && age <= 90))`  || `if (age < 14 || age > 90)`

A question about "if"

```
if (-1 || 0) alert( 'first' ); //first
if (-1 && 0) alert( 'second' ); // không chạy
if (null || -1 && 1) alert( 'third' ); //third
```


<a name="12"></a>
# 12.Loops: while and for (vòng lặp)

## The “while” loop (Vòng lặp while)

```
while (điều kiện) {
  // code
  // so-called "loop body"
}
```

Điều kiện đúng thì code mới được thực hiện.

```
let i = 0;
while (i < 3) { // shows 0, then 1, then 2
  alert( i );
  i++;
}
```

```
let i = 3;
while (i) { // khi i ==0 điều kiện sai kết thúc vòng lặp.
  alert( i );
  i--;
}
```

## The “do…while” loop (vòng lặp do...while)

```
do {
  // loop body
} while (condition);

```

Vòng lặp thục hiện 1 lần sau đó kiểm tra điều kiện, nếu đúng thì vòng lặp thục hiện thêm một lần nữa.

```
let i = 0;
do {
  alert( i );
  i++;
} while (i < 3);
```

## The “for” loop (Vòng lặp for)

Vòng lặp thường được sử dụng nhất.

```
for (begin; condition; step) {
  // ... loop body ...
}
```

```
for (let i = 0; i < 3; i++) { // shows 0, then 1, then 2
  alert(i);
}
```

## Breaking the loop

```
let sum = 0;

while (true) {

  let value = +prompt("Enter a number", '');

  if (!value) break; // (*)

  sum += value;

}
alert( 'Sum: ' + sum );
```

Chỉ thị thoát khỏi vòng lặp ở dòng * .

## Continue to the next iteration (continue tron lần kế tiếp.)

 Continue không dừng lại vòng lặp, thay vào đó, nó dừng lại sự lặp lại hiện tại và bắt buộc vòng lặp bắt đầu vòng lặp mới.

 Ví dụ vòng lặp tìm ra số lẽ:

 ```
for (let i = 0; i < 10; i++) {

  
  if (i % 2 == 0) continue; //nếu điều kiện đúng thì bỏ qua giá trị và thực hiện vòng lặp tiếp theo.

  alert(i); // 1, then 3, 5, 7, 9
}
 ```

 Ví dụ khác về in ra số lẽ:

 ```
for (let i = 0; i < 10; i++) {

  if (i % 2) {
    alert( i );
  }
}
 ```

**Chú ý**

`(i > 5) ? alert(i) : continue; // continue không được dùng ở đây.`

## Labels for break/continue (Nhãn cho break/continue)

Cú pháp:

```
labelName: for(...) {
...
}

```

Câu lệnh break nằm trong vòng lặp phá vỡ nhãn.

```
outer: for (let i = 0; i < 3; i++) {

  for (let j = 0; j < 3; j++) {

    let input = prompt(`Value at coords (${i},${j})`, '');

    // if an empty string or canceled, then break out of both loops
    if (!input) break outer; // (*)

    // do something with the value...
  }
}
alert('Done!');
```

Nhãn cũng có thể dùng cho `continue` trong trường hợp này nhảy đến vòng lặp kế tiếp.

**Nhãn không phải "goto"**

Nhãn không cho phép nhảy vào nơi mã tuỳ ý.

```
break label;  // jumps to label? No.

label: for(...)
```

Cuộc gọi đến break/continue chỉ có thể thực hiện từ bên trong vòng lặp, và nhãn phải ở đâu đó trên đầu từ hướng dẫn

## Tóm lược

Có 3 vòng lặp:

- while - kiểm tra điều kiện trước khi thực kiện.
- do..while - thực hiện một lần rồi mới kiểm tra điều kiện.
- for(;;) - điều kiện được kiểm tra trước mỗi lần lặp, cài đặt bổ xung có sẵn.

Break/Continue hỗ trợ nhãn trước khi vòng lặp.

## Task

What is the last value alerted by this code? Why?

```
let i = 3;

while (i) {
  alert( i-- ); // Giá trị cuối là 1 vì i-- .
}
```


Which values shows the while?

```
let i = 0;
while (++i < 5) alert( i ); // 1 2 3 4
```

```
let i = 0;
while (i++ < 5) alert( i ); // 1 2 3 4 5
```

Which values get shown by the "for" loop?

```
for (let i = 0; i < 5; i++) alert( i ); // 0 1 2 3 4
```

```
for (let i = 0; i < 5; ++i) alert( i ); // 0 1 2 3 4 
```

Output even numbers in the loop

```
for (let i = 2 ; i<= 10 ; i++)
    {
        alert(i);
    }
```

Replace "for" with "while"

```
let i = 0;
while(i<3)
{
     alert( `number ${i}!` );
    i++;
}
```

Repeat until the input is incorrect

```
let num;

 do
{
     num = prompt("Nhập vào một số:");
    if(num > 100)
    {
        alert("Vui lòng nhập lại !");
    }
} while(num > 100);

alert(`Số bạn vừa nhập là ${num}.`);
```

```
let num;

 do
{
     num = prompt("Nhập vào một số:");
     if(num == '')
    {
        break;
    }
    if(num < 100)
    {
        alert("Vui lòng nhập lại !");
    }
    
} while(num < 100);

alert(`Số bạn vừa nhập là ${num}.`);
```

Output prime numbers

```
let num = prompt("Nhập vào một số:");

next :
for ( let i = 2 ; i <= num ; i++)
{
    for ( let j = 2 ; j < i ; j++)
    {
        if(i%j == 0) continue next;
    }

    alert(i);
}

```

<a name="13"></a>
# 13. The "switch" statement.

Cú pháp:

```
switch(x) {
  case 'value1':  // if (x === 'value1')
    ...
    [break]

  case 'value2':  // if (x === 'value2')
    ...
    [break]

  default:
    ...
    [break]
}
```

Ví dụ:

```
let a = 2 + 2;

switch (a) {
  case 3:
    alert( 'Too small' );
    break;
  case 4:
    alert( 'Exactly!' );
    break;
  case 5:
    alert( 'Too large' );
    break;
  default:
    alert( "I don't know such values" );
```

Nếu không có break thì việc thực hiện tiếp tục với trường hợp tiếp theo mà không có bất kỳ kiểm tra.

Ví dụ:

```
let a = 2 + 2;

switch (a) {
  case 3:
    alert( 'Too small' );
  case 4:
    alert( 'Exactly!' );
  case 5:
    alert( 'Too big' );
  default:
    alert( "I don't know such values" );
```

## Grouping of “case” (nhóm các trường hợp)

```
let a = 2 + 2;

switch (a) {
  case 4:
    alert('Right!');
    break;

  case 3:                    // (*) grouped two cases
  case 5:
    alert('Wrong!');
    alert("Why don't you take a math class?");
    break;

  default:
    alert('The result is strange. Really.');
}
```

## Task

Rewrite the "switch" into an "if"

```
let browser = prompt("Nhập vào tên trình duyệt bạn đang sử dụng");

if(browser == 'Edge')
{
    alert("You have got the Edge.");
}
else if (browser == 'Chrome' || browser == 'Firefox' || browser == 'Safari' || browser == 'Opera')
{
    alert("Okey we support these browser too");
}
else
{
    alert("We hope that this page looks ok!");
}
```

Rewrite "if" into "switch"

```
let a = +prompt("a = ?");

switch(a)
{
    case 0: alert(0); break ;
    case 1: alert(1); break ;
    case 2:
    case 3: alert('2,3'); break;
}
```

<a name="14"></a>
# 14. Functions.

## Function Declaration

Để tạo một hàm ta sử dụng khai báo hàm.

```
function showMessage() {
  alert( 'Hello everyone!' );
}
```


Ví dụ:

```
function showMessage() {
  alert( 'Hello everyone!' );
}

showMessage();
showMessage();
```

## Local variables

Một biến khai báo bên trong một hàm chỉ hiển thị bên trong hàm đó.

```
function showMessage() {
  let message = "Hello, I'm JavaScript!"; // local variable

  alert( message );
}

showMessage(); // Hello, I'm JavaScript!

alert( message ); // <-- Error! biến chỉ sử dụng trong hàm, không được gọi ra ngoài.
```

## Outer variables

```
let userName = 'John';

function showMessage() {
  let message = 'Hello, ' + userName;
  alert(message);
}

showMessage(); // Hello, John
```

Hàm có toàn quyền truy cập vào biến ngoài. NÓ cũng có thể sữa đổi nó.

```
let userName = 'John';

function showMessage() {
  userName = "Bob"; // (1) changed the outer variable

  let message = 'Hello, ' + userName;
  alert(message);
}

alert( userName ); // John before the function call

showMessage();

alert( userName ); // Bob, giá trị đã được sữa đổi bởi hàm.
```

```
let userName = 'John';

function showMessage() {
  let userName = "Bob"; // declare a local variable

  let message = 'Hello, ' + userName; // Bob
  alert(message);
}

// the function will create and use it's own userName
showMessage();

alert( userName ); // John, unchanged, the function did not access the outer variable
```

Username trong và ngoài hàm là khác nhau.

## Parameters (Thông số)

Chúng ta có thể truyền dữ liệu tuỳ ý đến chức năng sử dụng các tham số (Còn gọi là các đối số chức năng).

Ví dụ:

```
function showMessage(from, hung) { // arguments: from, text
  alert(from + ': ' + hung);
}
let from=prompt("Your name:");


showMessage(from, 'Hello!'); 
showMessage(from, "What's up?");
```

## Default values

Nếu một tham số không được cung cấp, thì giá trị của nó không được xác định.

```
function showMessage(from, text = "no text given") {
  alert( from + ": " + text );
}

showMessage("Ann"); // Ann: no text given
```

```
function showMessage(from, text  )
 {
 if(text == '')
 {
    text = "no text given";
 }
  alert( from + ": " + text );
}

let from = prompt("Your name:");
let text = prompt("Câu chào:");

showMessage(from,text); // Ann: no text given
```

…Or the || operator:

```
function showMessage(from, text) {
  // nếu văn bản bị sai lệch thì văn bản sẽ bị "default" value
  text = text || 'no text given';
  ...
}
```

## Returning a value

Một hàm có thể trả lại một giá trị trở lại vào mã gọi là result.

```
function sum(a, b) {
  return a + b;
}

let result = sum(1, 2);
alert( result ); // 3
```

Ví dụ:

```
function checkAge(age) {
  if (age > 18) {
    return true;
  } else {
    return confirm('Got a permission from the parents?');
  }
}

let age = prompt('How old are you?', 18);

if ( checkAge(age) ) {
  alert( 'Access granted' );
} else {
  alert( 'Access denied' );
}
```

Có thể sử dụng return mà không có giá trị. Điều đó làm cho các chức năng để thoát ra ngay lập tức.

Ví dụ:

```
function showMovie(age) {
  if ( !checkAge(age) ) {
    return;
  }

  alert( "Showing you the movie" ); // (*)
  // ...
}
```


Nếu một hàm không trả về một giá trị, thì nó cũng giống như nếu nó trả về undefined:

```
function doNothing() { /* empty */ }

alert( doNothing() === undefined ); // true
```

Nên đặt giá trị trên cùng một dòng:

```
return
 (some + long + expression + or + whatever * f(a) + f(b))
```

Ở đâu JavaScript ngầm hiểu dấu `;` sau `return`.

## Naming a function

Hàm là hành động. Vì vậy, tên của họ thường là một động từ. Nó nên ngắn gọn, nhưng chính xác nhất có thể mô tả những gì các chức năng nào. Vì vậy, để một người đọc mã nhận được đầu mối đúng.

Hàm bắt đầu với..

`get` trả về giá trị.

`calc` tính toán một cái gì đó.

`create..` tạo một cái gì đó.

`check..` tính toán một cái gì đó.

Ví dụ:

```
showMessage(..)     // hiển thị thông báo
getAge(..)          // trả về giá trị tuổi
calcSum(..)         // tính tổng và trả về giá trị
createForm(..)      // tạo form
checkPermission(..) // kiểm tra chức năng, trả về true/false.
```

Tên hàm nên ngắn gọn, nhưng mang tính mô tả.

## Functions == Comments

```
function showPrimes(n) {
  nextPrime: for (let i = 2; i < n; i++) {

    for (let j = 2; j < i; j++) {
      if (i % j == 0) continue nextPrime;
    }

    alert( i ); // a prime
  }
}

let n = prompt("N=");
showPrimes(n);
```

```
function showPrimes(n) {

  for (let i = 2; i < n; i++) {
    if (!isPrime(i)) continue;

    alert(i);  // a prime
  }
}

function isPrime(n) {
  for (let i = 2; i < n; i++) {
    if ( n % i == 0) return false;
  }
  return true;
}
```

## Tóm lược.

Khai báo hàm:

```
function name(thông số phân cách bởi dấu phấy
    ) {
  /* code */
}
```

Một hàm có thể trả về giá trị, nếu không thì nó undefined.

Để cho đoạn code gọn và dễ hiểu, nên sử dụng các biến địa phương và các tham số trong hàm chứ không phải bên ngoài.

Tên hàm:

Một cái tên mô tả chức năng của nó.

Có nhiều tiền tố nổi tiếng (well-known): create..,get..,check.. Sử dụng chúng để gợi ý một chức năng nào đó.

## Task

Is "else" required?

```
function checkAge(age) {
  if (age > 18) {
    return true;
  } else {
    // ...
    return confirm('Did parents allow you?');
  }
}
```

```
function checkAge(age) {
  if (age > 18) {
    return true;
  }
  // ...
  return confirm('Did parents allow you?');
}
```

Không có sự khác nhau.

**Rewrite the function using '?' or '||'**

```
function checkAge(age) {
  return (age > 18) ? true : confirm('Did parents allow you?');
}
```

```
function checkAge(age) {
  return (age > 18) || confirm('Did parents allow you?');
}
```

**Function min(a, b)**

```
function min(a,b)
{
    minn = a;
    if(a>b)
    {
        minn = b;
    }
    alert(minn);
}

let a =prompt("a =");
let b =prompt("b =");
min(a,b);
```

**Function pow(x,n)**

```
function pow(x,n)
{
    let m = x;
    for (let i = 1 ; i < n ; i++)
    {
         m *= x;
    }
    alert(m);
}

let x =prompt("x =");
let n =prompt("n =");
if(n<=1)
{
    alert("Không hợp lệ!!");
}
else
{
    pow(x,n);   
}

```

<a name="15"></a>
# 15. Function expressions and arrows (biểu thức hàm và mũi tên)

Hàm là một giá trị đặc biệt.

Cú pháp trước đây được gọi là Function Declaration

```
function sayHi() {
  alert( "Hello" );
}
```

Có một cú pháp khác để tạo ra một hàm được gọi là Function Expression.

```
let sayHi = function() {
  alert( "Hello" );
};
```


Ở đây, hàm được tạo ta và gán cho biến một cách rõ ràng, như bất kỳ giá trị nào khác. Không có vấn đề, là thế nào các chức năng không xác định - nó chỉ là một giá trị, được lưu trữ trong các biến `sayHi`.

Ý nghĩa của các mẫu mã này là như nhau: tạo một hàm và đặt nó vào biến `sayHi`

Chúng tôi có thể in ra giá trị sử dụng `alert`.

```
function sayHi() {
  alert( "Hello" );
}

alert( sayHi ); // shows the function code
```

Xin lưu ý rằng dòng cuối cùng không chạy các hàm, vì không có dấu ngoặc đơn sau sayHi.

Chúng ta có thể sao chép hàm đến một biến khác:

```
function sayHi() {   // (1) create
  alert( "Hello" );
}

let func = sayHi;    // (2) copy

func(); // Hello     // (3) run the copy (it works)!
sayHi(); // Hello    //     this still works too (why wouldn't it)
```

Nó hoạt động như sau:

1. Function Declaration (1) tạo ra một hàm và đặt nó vào biến có tên sayHi.
2. Dòng (2) sao chép nó vào biến func.
    Xin lưu ý một lần nữa: không có dấu ngoặc đơn sau khi sayHi.Nếu chúng được, sau đó func = sayHi() sẽ viết kết quả của cuộc gọi sayHi() vào function, chứ không phải hàm sayHi.
3.Bây giờ hàm có thể được gọi là cả hai như sayHi() và func().

Chú ý rằng chúng ta cũng có thể đã sử dụng một biểu thức hàm để khai báo sayHi, trong dòng đầu tiên:

```
let sayHi = function() { ... };

let func = sayHi;
// ...
```

Mọi thứ sẽ làm việc như nhau. Thậm chí rõ ràng hơn những gì đang xỹ ra, phải không?.

**Tại sao lại có một dấu chấm phẩy ở cuối?**

Có thể có một câu hỏi, tại sao Function Expression có một dấu chấm phẩy ; ở cuối, và chức năng.

Tuyên bố là không:

Không cần thiết trong; Ở cuối các khối mã và các cấu trúc cú pháp sử dụng chúng như nếu {...}, cho {}, function f {} vv

Hàm chức năng được sử dụng bên trong câu lệnh: let sayHi = ...; như một giá trị. Nó không phải là một khối mã. Dấu chấm phẩy ; được khuyến cáo ở cuối báo cáo, không có vấn đề về giá trị. Vì vậy, dấy chấm phẩy ở đây không liên quan đến Function Expression theo bất kỳ cách nào, nó chỉ chấm dứt câu lệnh.

```
function sayHi() {
  // ...
}

let sayHi = function() {
  // ...
};
```



## Callback functions (gọi lại hàm)

```
function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}

function showOk() {
  alert( "You agreed." );
}

function showCancel() {
  alert( "You canceled the execution." );
}

// sử dụng: functions showOk, showCancel để hỏi
ask("Do you agree?", showOk, showCancel);
```

Bạn có thể sử dụng hàm để viết ngắn hơn.

```
function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}

ask(
  "Do you agree?",
  function() { alert("You agreed."); },
  function() { alert("You canceled the execution."); }
);
```


## Function Expression vs Function Declaration

Khai báo hàm:

```
/ Function Declaration
function sum(a, b) {
  return a + b;
}
```

-Hàm được tạo bên trong một biểu thức hoặc bên trong một cấu trúc cú phấp khác.

```
// Function Expression
let sum = function(a, b) {
  return a + b;
}
```

**Biểu thức hàm được tạo ra khi quá trình thực hiện được và có thể sử dụng kể từ đó.**

Function Declarations là khác nhau

**Function Declarations có thể sử dụng trong toàn bộ tập lệnh/khối mã.**

Hàm có thể gọi trước khi định nghĩa.

```
sayHi("John"); // Hello, John

function sayHi(name) {
  alert( `Hello, ${name}` );
}
```

Và nếu có Function Expression thì nó sẽ không hoạt động.

```
sayHi("John"); // error!

let sayHi = function(name) {  // (*) no magic any more
  alert( `Hello, ${name}` );
};
```

## Function Declaration trong một khối.

Khi khai báo hàm thì được thực hiện bên trong khối mã đó, nhưng bên ngoài thì không.

Code dưới đây không hoạt động:

```
let age = prompt("What is your age?", 18);

if (age < 18) {

  function welcome() {
    alert("Hello!");
  }

} else {

  function welcome() {
    alert("Greetings!");
  }

}

welcome(); // Error: welcome is not defined
```

Chúng ta có thể gọi nó từ một khối, nhưng không phải bên ngoài.

Ví dụ về code hoàn chỉnh

```
let age=prompt("Age = "); // take 16 as an example

if (age < 18) {
  welcome();               // \   (runs)
                           //  |
  function welcome() {     //  |
    alert("Hello!");       //  |  Function Declaration is available
  }                        //  |  everywhere in the block where it's declared
                           //  |
 // welcome();               // /   (runs)

} else {
   welcome();                        // \
  function welcome() {     //  |
    alert("Greetings!");   //  |  if age=16, the the execution does not go here,
  }                        //  |  so this "welcome" is never created
                           // /
}
```

Khi chúng ta khai báo một hàm, đầu tiên ta cần xem xét là cú pháp khai báo hàm, cái mà chúng ta sử dụng trước đây. Nó cho phép tự do hơn trong cách tổ chức mã của chúng ta, bởi vì chúng ta có thể gọi các hàm như vậy trước khi chúng được khai báo.

## Arrow functions (mũi tên hàm)

Cú pháp:

`let func = (arg1, arg2, ...argN) => expression`

Nó giống như:

```
let func = function(arg1, arg2, ...argN) {
  return expression;
}
```

Ví dụ:

```
let sum = (a, b) => a + b;

alert( sum(1, 2) ); // 3
```

**Multiline arrow functions** Các chức năng mũi tên đa dòng.

```
let sum = (a, b) => {  // the figure bracket opens a multiline function
  let result = a + b;
  alert(result);
  //return result; // if we use figure brackets, must use return
};

//alert( sum(1, 2) ); // 3

sum(1,2);
```

## Tóm lược

Hàm là giá trị. Nó có thể được sao chép gán hoặc khai báo bất kỳ vị trí nào của mã.

Nếu hàm được khai báo như một câu lệnh riêng, trong dòng mã chính - được gọi mà "Function Declaration".

Nêu nó được tạo ra như một phần của một biểu thức - đó là "Function Expression".

Function Declaration được xử lý trước khi khối mã thực thi. Chúng có thể nhìn thấy ở khắp mọi nơi trong khối.

Trong hầu hết các trường hợp khi chúng ta cần khai báo một hàm, thì Function Declaration là thích hợp, bởi vì có thể nhìn thấy trước bản tuyên bố. Điều đó mang lại sự linh hoạt hơn trong việc tổ chức mã. Và thường dễ đọc hơn.

## Task 

Rewrite with arrow functions

```
function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}

ask(
  "Do you agree?",
  () => alert("You agreed."),
  () => alert("You canceled the execution.")
);
```

<a name="16"></a>
# 16. JavaScript specials

## Code structure.

Các lệnh được phân cách bởi dấy chấm phẩy.

`alert('Hello'); alert('World');`

Thông thường, xuống dòng cũng được coi là một dấu phân cách, do đó cũng sẽ làm việc:

```
alert('Hello')
alert('World')
```

Đó gọi là chèn dấu phẩy tự động. Đôi khi nó không hoạt động.

```
alert("There will be an error after this message")

[1, 2].forEach(alert)
```

Nên đặt dấu chấm phẩy ở cuối mỗi câu lệnh.

## Strict mode (chế độ nghiêm ngặt)

Để kích hoạt đầy đủ các tính năng của JavaScript hiện đại, chúng ta nên bắt đầu các Script với "use strict".

```
'use strict';

...
```

Chỉ thị có thể nằm ở đầu một script hoặc ở đầu một hàm.

Nếu không sử dụng "use strict", mọi thứ vẫn hoạt động, nhưng một số tính năng cư sử theo phong cách cổ điển, tương thích cách. Chúng tôi thường thích hành vi hiện đại.

Một số tính năng hiện đại của ngôn ngữ như classes cho phép sử dụng "use strict" ngầm.

## Variables

**Có thể khai báo bằng cách sử dụng:

`let`

`const` : Không thể thay đổi.

`var` Kiểu cũ.

**Một tên biến có thể bao gồm**

Các chữ cái và số, nhưng ký tự đầu tiên có thể không phải là một chữ số.

Ký tự `$` và `_` là bình thường, ngang bằng các chữ cái.

Ngoài ra bảng chữ cái Latinh và chữ tượng hình cũng không được phép, nhưng thường không được sử dụng.

Các biến cỏ thể lưu động - chúng có thể lưu trữ bất kỳ giá tri nào:

```
let x = 5;
x = "John";
```

**Có 7 loại dữ liệu**

`number` Cho cả dấu chấm động và số nguyên.

`string` Cho chuỗi

`boolean` cho các giá trị logic true/false.

`null` một loại với một giá trị null, có nghĩa là "trống rỗng" hoặc "không tồn tại".

`undefined` Một loại với một giá trị duy nhất không xác định, có nghĩa là "không chỉ định".

`object` and `symbol` đối với các cấu trúc dữ liệu phức tạp và các định danh duy nhất, chúng tôi đã không học được chúng.

Toán tử `typeof` trả về kiểu cho một giá trị với hai trường hợp ngoại lệ: 

```
typeof null == "object" // error in the language
typeof function(){} == "function" // functions are treated specially
```


## Interaction (sự tương tác)

Chúng tôi sử dụng các trình duyệt làm môi trường làm việc, vì vậy các chức năng UI cở bản sẽ là:

[prompt(question[, default])](#000)

Đặt một câu hỏi, và trả lại những gì mà khách truy cập hoặc không hợp lệ nếu nhận huỷ bỏ.

[confirm(question)](#00)

Đặt một câu hỏi và đề nghị chọn giữa OK và Cancel. SỰ lựa chọn  được trả về là true/false.

[alert(message)](#0000)

Xuất ra thông báo.

Tất cả các chức năng này là phương thức, họ tạm dừng việc thực hiện mã và ngăn không cho khách truy cập tương tác với trang cho đến khi anh ta trả lời.

Ví dụ:

```
let userName = prompt("Your name?", "Alice");
let isTeaWanted = confirm("Do you want some tea?");

alert( "Visitor: " + userName ); // Alice
alert( "Tea wanted: " + isTeaWanted ); // true
```


## Operators toán tử.

Javascript hỗ trợ các toán tử sau:

**Tính số học** 

Thường : `+ - * /` cũng có `%` chia lấy phần dư và `**`  cho bình phương của một số.

Nhị phân cộng `+` nối các xâu. Và nếu có một trong các toán hạng là một chuỗi - một trong những khác được chuyển thành chuỗi:

```
alert( '1' + 2 ); // '12', string
alert( 1 + '2' ); // '12', string
```


 **Assignments**

Có một công việc đơn giản: a = b và những kết hơp như a *= 2.

**Bitwise**

Các toán tử BitWise làm việc với số nguyên trên bit-level: xem các tài liệu khi cần thiết.


**Ternary**

Các nhà điều hành duy nhất với ba tham số: `cond ? result a : result b`. Nếu `cond` đúng thì trả về `result a`, nếu không thì `result b`.

**Logical operators** Toán tử logic.

AND  && và OR || thực hiện đánh giá ngắn mạch và sau đó trả lại giá trị mà nó dừng lại.

## Comparisons (so sánh)

Kiểm tra `==` cho các giá trị của các kiểu khác nhau chuyể đổi giữa chúng thành một số (ngoại trừ null và undifened bằng nhau và không có gì khác), do đó, những giá trị này bằng nhau:

```
alert( 0 == false ); // true
alert( 0 == '' ); // true
```

Các so sánh khác cung có thể chuyển thành một số.

Toán tử kiểm tra nghiêm ngặt `===` không thực iện việc chuyển đổi: các kiểu khác nhau luôn có nghĩa các giá trị khác nhau cho nó, do đó:

Giá trị null và undefined là đặc biệt: chúng bằng `===` và không bằng bất cứ giá trị nào khác.

So sánh nhiều hơn/ ít hơn so sánh character-by-character, các loại khác được chuyển đổi sang một số.

**Logical operators** Toán tử logic.

Có rất ít, như toán tử dấu phẩy.

## Loops

Chúng ta có 3 vòng lặp:

```
// 1
while (condition) {
  ...
}

// 2
do {
  ...
} while (condition);

// 3
for(let i = 0; i < 10; i++) {
  ...
}
```

Biến khai báo cho vòng lặp for được hiển thị bên trong vòng lặp. Nhưng ta cũng có thể bỏ qua cho và sử dụng lại một biển hiện có.

Chỉ thị break/continue cho phép thoát khỏi toàn bộ vòng lặp/ vòng lặp hiện tại. Sử dụng nhãn để phá vỡ các vòng lặp lồng nhau.

## The “switch” construct

Các switch được xây dựng có thể thay thế nhiều nếu kiểm tra. Nó sử dụng === để so sánh.

Ví dụ:

```
let age = prompt('Your age?', 18);

switch (age) {
  case 18:
    alert("Won't work"); // the result of prompt is a string, not a number

  case "18":
    alert("This works!");
    break;

  default:
    alert("Any value not equal to one above");
}
```

## Functions

Có 3 cách để tạo ra một hàm:

1. Hàm trong dòng mã chính.

```
function sum(a, b) {
  let result = a + b;

  return result;
}
```

2. Hàm trong ngữ cảnh của một biểu thức.

```
let sum = function(a, b) {
  let result = a + b;

  return result;
}
```

Hàm có một cái tên nhưng cái tên đó chỉ hiển thị bên trong hàm đó.

3. Hàm mũi tên.

```
// expression at the right side
let sum = (a, b) => a + b;

// or multiline syntax with { ... }, need return here:
let sum = (a, b) => {
  // ...
  return a + b;
}

// without arguments
let sayHi = () => alert("Hello");

// with a single argument
let double = n => n * 2;
```

Các hàm có thể có biến địa phương - những biến địa phương được khai báo bên trong hàm. Các biến như vậy chỉ có thể sử dụng trong hàm.

Tham số có thể có các giá trị mặc định.

Hàm luôn trả về một cái gì đó. Nếu không có câu trả lời, kết quả sẽ không được xác định.

**Function Declaration** hiển thị trong toàn bộ khối mã.

**Function Expression** tạo khi thực hiện đến
                        có thể có 1 cái tên, chỉ có thể sử dụng bên trong hàm.


## [More to come ](#15151)

Đó là một danh sách ngắn các tính năng của JavaScript. Hiện tại chúng tôi chỉ nghiên cứu những điều cơ bản. Hơn nữa trong hướng dẫn, bạn sẽ tìm thấy nhiều đặc biệt hơn và các tính năng tiên tiến của JavaScript.

<a name="b"></a>
# B.Tổng kết.
