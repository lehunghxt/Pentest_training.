# Người thực Hiện: Hoả Ngọc Lê Hùng.

# Task 10 :Đọc và dịch sách HTTP Essentials

# AT13M

# Mục Lục.

# [A.Nội dung.](#a)

# [Chương I.](#chuong1)

## [1.1 HTTP and the World Wide Web.](#1.1)

## [1.2 Protocol Layers (Các lớp giao thức)](#1.2)

## [1.3 Uniform Resource Identifiers ( Định dạng tài nguyên thống nhất. )](#1.3)

## [1.4 Organization of this book (Tổ chức của cuốn sách này)](#1.4)

# [B.Tổng Kết.](#b)

<a name="chuong1"></a>
# Chương I.

<a name="1.1"></a>
## 1.1 HTTP and the World Wide Web.

Internet có thể theo dõi nguồn gốc của nó để nghiên cứu dự án, bắt đầu vào năm 1960 bởi quốc phòng hoa kỳ. Một người anh vật lý làm việc ở thuỵ sỹ, tuy nhiên có ảnh hưởng đáng kể đến Internet ngày nay hơn bất kỳ người nào khác. Nó vào tháng ba năm 1989 rằng Tim Berners-lee lần đầu tiên vạch ra những lợi thế của một siêu văn bản, dựa trên hệ thống thông tin xoắn. Và vào cuối năm 1990, berners-lee, cùng với Robert Cailliau, tạo ra các trình duyệt web và máy chủ đầu tiên. Những trình duyệt này cần một giao thức để điều khiển truyền thông của họ; Cho rằng Berners-lee và Cailliau thiết kế phiên bản đầu tiên của HTTP.

Kể từ đó, Lưu lượng truy cập web đã phát triển để thống trị trên Internet. Vào năm 1998, HTTP chiếm hơn 75% lưu lượng truy cập trên xương sống của Internet lướt các giao thức khác như email, truyền tệp và đăng nhập từ xa. Ngày nay, ít nhất là trong ngôn ngữ phổ biến, thế giới web là internet. Và web tiếp tục phát triển. Vào cuối năm 2000, vì cuốn sách này đang gần hoàn thành, dự án kiểm duyệt báo cáo rằng web đã khoảng: 
- 2 700 000 000 trang
- 50 700 000 000 000 byte của văn bản
- 608 000 000 hình ảnh
- 10 100 000 000 000 byte dữ liệu hình ảnh

Trong 24 giờ trước đó, trang web thêm:
- 5 490 000 trang mới
- 103 000 000 000 byte mới của văn bản
- 1 240 000 hình ảnh mới
- 20 600 000 000 byte dữ liệu hình ảnh mới

Giao thức truyền siêu văn bản đã phát triển cùng với đặc tả web ban đầu từ HTTP vừa vặn trên một trang duy nhất và dài 656 từ, có thể được đọc và hiểu chỉ trong vài phút. Ngược lại, đặc tả HTTP phiên bản 1.1 trải dài một số tài liệu. Tài liệu chính chỉ gói gọn gần 60 000 từ trong 176 trang.

176 trang của đặc tả HTTP chính, cùng với các tài liệu khác tạo nên chuẩn HTTP, xác định các quy tắc của trình duyệt web, máy chủ web, proxy và các loại khác. . Các tiêu chuẩn HTTP không dictate những thông tin trao đổi hệ thống khi họ thiết lập truyền thông. Thật vậy, một trong những thế mạnh lớn nhất của HTTP là khả năng chứa hầu như bất kỳ loại trao đổi thông tin. Ví dụ, các trang web được tạo ra theo các quy tắc cho ngôn ngữ đánh dấu siêu văn bản, hoặc html (cũng được phát minh bởi berners-lee). Nhưng HTTP cũng không kém khi truyền các hướng dẫn in, các tệp chương trình và đối tượng đa phương tiện. Với sự phổ biến của các trình duyệt web, tính phổ biến của Internet, sức mạnh và tính linh hoạt của HTTP mà Berners-Lee và Cailliau đã phát triển, cuối cùng có thể trở thành nền tảng cho tất cả các tính toán dựa trên mạng.

<a name="1.2"></a>
## 1.2 Protocol Layers (Các lớp giao thức)

Để hiểu được HTTP, nó giúp hiểu biết một chút về kiến ​​trúc của internet. Chúng ta có thể nhìn vào kiến ​​trúc của Internet từ hai quan điểm. Theo quan điểm này, Internet là một tập hợp các kết nối lỏng lẻo của tất cả các kích cỡ và kiểu mà các hệ thống vật lý, tuy nhiên chúng ta sẽ tập trung vào việc nghiên cứu, Internet là một tập hợp các giao thức truyền thông khác nhau, các giao thức này hợp tác để cung cấp dịch vụ.

Cung cấp dịch vụ qua internet thực sự là một cam kết rất phức tạp. Để làm cho thách thức dễ quản lý hơn, các nhà thiết kế internet đã chia công việc thành các thành phần khác nhau và đưa các thành phần đó vào một số giao thức truyền thông khác nhau thành các lớp.

Hình 1.1 cho thấy bốn lớp giao thức với một hệ thống máy tính. Giao thức lớp thấp nhất kiểm soát công nghệ mạng cụ thể, cho dù đó là Ethernet lan, moden quay số, liên kết sợi quang hay bất kỳ công nghệ nào khác. Một trong những thế mạnh lớn nhất của Internet là khả năng thích ứng với tất cả các loại công nghệ mạng. Cô lập các giao thức cho công nghệ đó trong lớp riêng của nó một trong những lý do cho sự linh hoạt; Hỗ trợ một công nghệ mạng mới là đơn giản là một vấn đề thực hiện một giao thức tầng thấp thích hợp.

<img src="http://sv1.upsieutoc.com/2017/05/21/http.png" >

Các hệ thống giao tiếp qua Internet sử dụng một số giao thức. Mỗi giao thức hoạt động ở lớp riêng của nó trong một chồng giao thức, hoàn thành các trách nhiệm cụ thể. Hình này cho thấy bốn lớp giao thức được sử dụng trong một trao đổi HTTP. HTTP chính nó là ứng dụng.

Lớp giao thức ngay phía trên công nghệ mạng là Giao thức Internet, hoặc IP. Và thậm chí  ip có thể không nổi tiếng như các giao thức khác trên Internet, nó có thể dễ dàng biện minh cho tên của nó như là công nghệ mạng giống nhau, và các hệ thống khác nhau dựa vào giao thức truyền tải và ứng dụng khác nhau. Tất cả các hệ thống trên Internet. Các giao thức Internet của trách nhiệm chính là nói chuyện các gói tin cá nhân  thông tin và chuyển tiếp các hệ thống yêu cầu trao đổi nhiều gói tin, và ip chịu trách nhiệm cho mỗi một gói tin.

Giao thức kế tiếp là giao thức truyền tải. Internet nói chung sử dụng ba giao thức truyền tải khác nhau, nhưng giao tiếp web đặc biệt sử dụng một: Transmission Control Protocol (TCP). Mặc dù IP có trách nhiệm chuyển các gói tin từ máy này sang máy khác, TCP làm cho việc truyền thông tin có thể được hiệu chỉnh. Nó đảm bảo rằng các gói dữ liệu theo đúng thứ tự, không ai bị mất trong quá trình và không có lỗi nào xuất hiện.

Lớp giao thức cuối cùng là ứng dụng. Giao thức này thực sự làm một cái gì đó có ý nghĩa với thông tin được trao đổi, bao gồm cả việc tổ chức trao đổi vào cuộc trò chuyện. Giao thức ứng dụng mà chúng ta quan tâm nhất là couse, HTTP, nhưng có rất nhiều các giao thức ứng dụng khác trên thư điện tử, để thiết lập các cuộc gọi điện thoại, cho phép ủy nhiệm phiên quay số, và như vậy. Tất nhiên, như chúng tôi đã lưu ý trước đó, giao tiếp HTTP là phần lớn lưu lượng truy cập trên Internet ngày nay.

Tổ chức giao thức nội bộ của một hệ thống không phải là điều quan trọng cho truyền thông. Rốt cuộc, phải mất nhiều hơn một hệ thống mới có được những liên lạc có ý nghĩa. Hình 1.2 mở rộng hình ảnh trước đó bằng cách đưa một hệ thống thứ hai vào sơ đồ. Bây giờ chúng ta có thể bắt đầu thấy cách giao tiếp thực sự diễn ra.

<img src="http://sv1.upsieutoc.com/2017/05/21/hung.png">

Hình vẽ hiển thị mũi tên màu đen giữa các lớp giao thức khác nhau trong một hệ thống. Những mũi tên này đại diện cho sự tương tác trực tiếp. Giao thức ứng dụng trong một hệ thống tương tác trực tiếp với giao thức truyền tải. Giao thức đó lần lượt tương tác trực tiếp với IP và IP tương tác với với giao thức kiếm soát công nghệ mạng. Các hệ thống khác nhau có thể trược tiếp tương tác với nhau thông qua công nghệ mạng. Hình 1.2 cũng cho thấy một hình thức tương tác khác. Mũi tên màu xám đại diện cho một sự tương tác với tương tác của nó trong một hệ thống. Do đó ngay khi cả ứng dụng nó một hệ thống trực tiếp chỉ giao tiếp với TCP, kết quả của tương tác đó là một giao tiếp logic với ứng dụng trong một hệ thống khác. Trong trường hợp của HTTP, việc triển khai HTTP trong một hệ thống có hiệu quả giao tiếp với việc khai thác HTTP ở một trang khác có thể là một máy chủ Web.

Để xem quá trình này một các chi tiết hơn chúng ta hãy xem cách một thông điệp HTTP thực hiện theo cách của nó từ trình duyệt web của bạn đến một mấy chủ web trên internet.

<img src="http://sv1.upsieutoc.com/2017/05/21/12384de6.png">

O> Hình 1.3 : Khi ứng dụng HTTP có một tin nhắn gửi đến, nó sẽ làm cho thông điệp trở thành giao thức thấp hơn. Thông điệp tiếp xúc thông qua toàn bộ giao thức ngăn sắp xếp cho đến khi nó rời khỏi hệ thống. 

Hình 1.3 hiển thị bốn bước đầu tiên trong qui trình. Đầu tiên quá trình HTTP xây dựng các thông điệp mà nó muốn gửi đi; sau đó trong bước 1, nó thông báo cho một quá trình TCP. Quá trình TCP thêm thông tin cụ thể TCP vào tin nhắn, tạo ra một phân đoạn TCP. Bổ sung này hoạt động rất nhiều như phong bì làm cho chữ thường. Các chữ cái mang thông tin thực tế, nhưng chúng tôi đính kèm chúng trong phong bì vì lợi ích của dịch vụ bưu chính. Dịch vụ bưu chính sử dụng thông tin về địa chỉ trên bao thư để gủi thư, mà không cần quan tân đến nội dung thư. Trong bước 2, quá trình TCP được xây dựng trên phân đoạn này cho quá trình IP. Quá trình IP được xây dựng trên phân khúc này bằng cách thêm nhiều thông tin, có hiệu lực thêm phong bì khác. Kết quả của một gói tin IP, trong bước 3, đạt đến việc thực hiện giao thức kiểm soát công nghệ mạng của hệ thống. Chỉ trong bược 4, sau khi vẫn còn nhiều thông tin thực sự rời khỏi hệ thống máy tính. Nó để lại dưới dạng một gói khung.

Hình 1.4 hoàn thành ví dụ bằng cách hiển thị những gì xảy ra khi gói tin đến máy chủ Web. Nó có thể đi qua những hệ thống và qua nhiều công nghệ mạng khác nhau để đến đó, nhưng các bước trung gian này không quan trọng đối với trình duyệt của máy chủ Web. Quá trình hình 4 cho thấy thực sự là đảo ngược của bốn bước đầu tiên. Mỗi lớp giao thức chấp nhận thông điệp, xử lý nó khi cần thiết và truyền thông tin đã được giải nén đến giao thức cao nhất tiếp theo. Cuối cùng, trong bước 8, thông báo HTTP ban đầu đến nơi ứng dụng máy chủ Web.

Trong cuốn sách này chúng ta sẽ chủ yếu quan tâm đến giao thức lớp ứng dụng - chủ yếu là HTTP, mặc dù chương 5 giới thiệu một vài giao thức ứng dụng liên quan khác. Bởi vì HTTP dựa vào TCP để mang Message của nó, tuy nhiên, chúng tôi sẽ đôi khi thảo luận về sự phân đoạn giựa HTTP và TCP; Những tương tác đó có thể dẫn chúng ta đến sự phát triển của nhiều tính năng quan trọng trong HTTP.



<img src="http://sv1.upsieutoc.com/2017/05/23/13123.png">

o> Hình 1.2 HTTP message đến trong một hệ thống đi lên nghĩ lớp giao thức cho đến khi họ đạt đến lớp ứng dụng. Mỗi giao thức loại bỏ thông tin cụ thể riêng của nó, như các gói tin mạng trở thành dữ liệu IP và sau đó phân đoạn TCP. Cuối cùng, thông báo HTTP đến nơi quy trình ứng dụng HTTP.

<a name="1.3"></a>
## 1.3 Uniform Resource Identifiers ( Định dạng tài nguyên thống nhất. )

Rất có thể, bạn đã quen thuộc với bộ định vị tài nguyên thống nhất, hoặc các url. Đây chỉ là địa chỉ chúng tôi sử dụng để đặt tên cho các trang Web; http://www.waterscreek.com là một ví dụ. Bạn có thể hơi ngạc nhiên khi bạn thấy rằng HTTP liên tục đề cập đến định dạng tài nguyên thống nhất hoặc uris. Trên thực tế, không có sự khác biệt thực sự giữa hai khái niệm. Về mặt kỹ thuật, một url chỉ là một uri. Rốt cuộc,  một cách để xác định một đối tượng mô tả một vị trí của nó. Như là một vấn đề thực tế, tuy nhiên, hai thuật ngữ là tương đương. Cuốn sách này nói chung sử dụng uri vì đó là thuật ngữ các thông số kỹ thuật HTTP. Nếu bất cứ khi nào bạn nhìn thấy "URI", bạn dịch nó như là  "URL", bạn sẽ không bị ảnh hưởng xấu.

Trong bất kì trường hợp nào, URI có thể chứa rất nhiều thông tin, và sự hiểu biết về cấu trúc của URI là hữu ích trong việc đánh giá một số khía cạnh của HTTP. Hình 1.5 cho thấy một mấu URI với gần như tất cả các yếu tố có thể. (Nhập URI này trong một trình duyệt Web thực sự làm việc khi cuốn sách này được viết, tất nhiên, không có bảo đảm sẽ là trường hợp sau xuất bản), Bảng 1.1 danh sách các thành phần của URI, cùng với một mô tả của mỗi người sử dụng.

<img src="http://sv1.upsieutoc.com/2017/05/23/hung132132132.png">

o> Hình 1.5 Một định danh tài nguyên thống nhất (URI) bao gồm nhiều thành phần riêng lẽ.

<img src="http://sv1.upsieutoc.com/2017/05/23/huyen.123.13.png">

Bảng 1.1: Các thành phần của một định dạng tài nguyên thống nhất.

<hr>

protocol : Xác định các giao thức ứng dụng cần thiết để truy cập tài nguyên, trong trường hợp này HTTP.

username: Nếu giao thức hỗ trợ khái niệm tên người dùng, điều này cung cấp tên người dùng có quyền truy cập vào tài nguyên; Ví dụ có một tên người dùng "khách".

password: Mật khẩu liên quan đến tên người dùng, bí mật trong ví dụ.

host: Hệ thống thông tin có nguồn; Cho HTTP đây là máy chủ web, www.ietf.org là một ví dụ.

port: Cổng TCP mà các giao thức ứng dụng nên sử dụng truy cập tài nguyên; Nhiều giao thức có cổng TCP ngụ ý (đối với cổng HTTP là 80), nhưng có thể được ghi đè ở đây nếu cần.

path: Các đường dẫn thông qua một tổ chức có thứ bậc theo đó các tài nguyên được đặt, thường là một cấu trúc thư mục hệ thống tập tin ở đây nếu cần thiết.

file: Bản thân nguồn lực.

query: Thêm thông tin về tài nguyên hoặc khách hàng.

fregment: Một vị trí cụ thể trong tài nguyên.

<hr>
<a name="1.4"></a>
##  1.4 Organization of this book (Tổ chức của cuốn sách này)
Nếu giao thức hỗ trợ khái niệm tên người dùng, điều này cung cấp tên người dùng có quyền truy cập vào tài nguyên; Ví dụ có một tên người dùng "khách".

password: Mật khẩu liên quan đến tên người dùng, bí mật trong ví dụ.

host: Hệ thống thông tin có nguồn; Cho HTTP đây là máy chủ web, www.ietf.org là một ví dụ.

port: Cổng TCP mà các giao thức ứng dụng nên sử dụng truy cập tài nguyên; Nhiều giao thức có cổng TCP ngụ ý (đối với cổng HTTP là 80), nhưng có thể được ghi đè ở đây nếu cần.

path: Các đường dẫn thông qua một tổ chức có thứ bậc theo đó các tài nguyên được đặt, thường là một cấu trúc thư mục hệ thống tập tin ở đây nếu cần thiết.

file: Bản thân nguồn lực.

query: Thêm thông tin về tài nguyên hoặc khách hàng.

fregment: Một vị trí cụ thể trong tài nguyên.
Phần còn lại của cuốn sách này bao gồm bốn chương và hai phụ lục. Chương tiếp theo, chương 2, bắt đầu nhìn vào giao thức truyền siêu văn bản. Chương này mô tả hoạt động của giao thức, tập trung vào những gì HTTP làm mà không lo lắng quá nhiều về các chi tiết nội bộ của giao thức. Chúng tôi sẽ không bỏ qua những chi tiết nội bộ. Tuy nhiên đây là các chủ đề của chương 3, nó xem xét chi tiết cấu trúc của các HTTP Message. Hai chương sau xem xét hai khía cạnh chính của bất kỳ sử dụng thực tế của HTTP, bảo mật và hiệu suất. Chương 4 nhìn sâu về bảo mật truyền thông HTTP bằng cách sử dụng cả hai phương tiện của HTTP chính nó cũng như các giao thức bổ sung khác nhau. Chương 5 nhà cung cấp cung cấp tổng quan về nhiều giao thức bổ sung và technologis có thể cải thiện hiệu suất http, đặc biệt là cân bằng tải và bộ nhớ đệm. Cuốn sách này tập trung vào phiên bản mới nhất của http, phiên bản 1.1. Trong phụ lục liên kết với nhau nhiều khía cạnh của http được đề cập đến trong cuốn sách. Thay vì mô tả và giải thích công nghệ cho một vấn đề quan trọng và gây nhiều tranh cãi, xây dựng các trang web chống đạn. Đóng sách với một danh sách các tài liệu tham khảo chú thích, một bảng chú giải thuật ngữ, và một chỉ mục.


# Chương II. HTTP Operation - How Clients & Servers Use HTTP

Chương này khám phá những gì HTTP cho phép giao tiếp hệ thống làm, và làm thế nào các hệ thống là về nó. Đầu tiên, chương này giới thiệu khái niệm cơ bản để hoạt động của HTTP sự khắc biệt giữa khách hàng và máy chủ HTTP. Ba phần sau chia các chức năng của HTTP thành ba loại, dựa trên cách hệ thống Web sử dụng chúng như thế nào: Hành động mà người dùng khởi tạo, chức năng mà khách hàng như trình duyệt web thường minh bạch đối với người dùng, và các hoạt động diễn ra sâu trong mạng. Chương kết luận với một lời giải thích về một điều quan trọng và thường xuyên tính năng HTTP gây ra tranh cải, quản lý nhà nước thông qua Cookies.

## 2.1 Client and Servers

Giống như nhiều giao thức truyền thông, HTTP tạo ra sự khác biệt quan trọng giữa hai bên giao tiếp. Trong bất ký HTTP trao đổi, một hệ thống giả định vai trò của một khách hàng trong khi khác máy chủ. Sự khác biệt này là rất quan trọng, như HTTP yêu cầu khách hàng và máy chủ để làm theo rất khác nhau qui tắc và thủ tục. Trong một phiên Web session, trình duyệt web PC là  một khách hàng HTTP, trong khi hệ thống lưu trữ các web site hoạt động như một máy chủ HTTP. Mặc dù hai hệ thống cả hai giao tiếp bằng cách sử dụng HTTP, rõ ràng họ có rất nhiều trách nhiệm khác nhau trong giao tiếp đó. Như chúng ta sẽ thấy trong phần này, khách hàng, ngườ dùng luôn khởi xướng HTTP trong truyền thông, kiểm soát một số đặc điểm quan trọng của phiên, bao gồm kết nối TCP đơn giản.

## 2.1.1 Initiating Communication (Khởi động truyền thông)

Sự khác biệt rõ ràng nhất giữa các máy khách và máy chủ HTTP là trách nhiệm bắt đầu giao tiếp. Chỉ một khách hàng có thể làm điều đó. Máy chủ có thể có rất nhiều không tin đó có thể cung cấp và nhiều chức năng nó có thể thực hiện, nhưng nó có một cái gì đó  chỉ khi được yêu cầu làm như vậy bợi một khách hàng. Một HTTP hành vi của khách hàng và máy chủ HTTP phản ứng. Hình 2.1 minh hoạ một trao đổi điển hình. Trình duyệt web, trong vai trò của khách hàng, gửi yêu cầu đến một máy chủ web. Máy chủ web sau đó trả về một phản hồi cho khách hàng đó. Khách hàng có thể thực hiện thêm hành động dựa trên phản hồi của máy chủ, nhưng http cho rằng hành động đó là cuộc trao đổi hoàn toàn mới. Cái mới trao đổi, giống như mọi giao dịch http, bắt đầu với giao dịch của khách hàng yêu cầu.

<img src="http://sv1.upsieutoc.com/2017/06/01/124.png">

Hình 2.1: Khách hàng bắt đầu truyền thông trao đổi bằng cách gửi yêu cầu đến máy chủ. Máy chủ chỉ đơn giản đáp ứng yêu cầu khách hàng. Nó không bắt đầu truyền thông của riêng mình.

## 2.1.2 Connections

Giống như bất kì giao thức ứng dụng nào sử dụng TCP, HTTP yêu cầu một TCP kết nối. Bởi vì khách hàng HTTP chịu trách nhiệm bắt đầu truyền thông HTTP, khách hàng cũng là  chịu trách nhiệm để bắt đầu quá trính kết nối TCP như hình 2.2 cho thấy, quá trình này yêu cầu trao đổi ba tin nhắn TCP. Các thông điệp TCP được hiển thị bằng màu xám văn bản. Sau khi trao đổi TCP đầu, khách hàng có thể gửi HTTP yêu cầu. Yêu cầu đó đáp ứng của máy chủ là màu đen văn bản. Hình này cũng hiển thị các thông báo yêu cầu đóng TCP kết nối. Máy chủ khởi tạo giao dịch 
này vì nó biết khi nào nó đã hoàn thành yêu cầu của khách hàng.

```
TCP Connections
Hình 2.2 điểm nổi bật đặc tính của các thông điệp TCP. 
Thông điệp đầu tiên mà khách hàng gửi có một SYN, cho "đồng bộ hoá" cờ. 
SYN chỉ ra rằng khách hàng mong muốn thiết lập một kết nối. 
Máy chủ trả lời bằng cách đặt SYN và ACK (cho"thừa nhận") cờ, cho biết sự sẵn lòng chấp nhận kết nối. 
Khách hàng hoàn thành cơ sở kết nối bằng chỉ gửi một tin nhắn TCP cờ ACK. 
Ba thông điệp thường được gọi là "bắt tay ba cách". Đóng của kết nối chỉ đòi hỏi hai tin nhắn. 
Đầu tiên FIN (cho "finished") cờ, và thứ hai có cả cờ FIN và ACK bộ.
```

## 2.1.3 Persistence (Sự tồn tại)

Các phiên bản của khách hàng yêu cầu HTTP thiết lập kết nối TCP riêng với mỗi yêu cầu. Đối với web đơn giản, yêu cầu này không có nhiều vấn đề. Tuy nhiên, khi trang web trở nên phức tạp hơn cà đồ hoạ, tuy nhiên TCP có cơ sở kết nối bắt đầu có hiệu quả đáng chú ý về hiệu suất web. Đó là vì các trang web phức tạp bao gồm nhiều đối tượng riêng biệt, và khách hàng phải phát hành một yêu cầu HTTP tách biệt để lấy ra các đối tượng đó. Các ví dụ như trang web hình 2.3 chứa hơn 20 đối tượng (trang đó, cộng với các yếu tố đồ hoạ cá nhân). Với phiên bản đầu của HTTP, trình duyệt web sẽ phải thiết lập hơn 20 kết nối riêng biệt trước khi có thể hiển thị trang. Phiên bản 1.1 của giao thức HTTP loại bỏ vấn đề nhiều kết nối TCP với một tính năng được biết đến như sự kiên trì (Mặc dù sự kiên trì đã được giới thiệu trong HTTP phiên bản 1.0 không phải tất cả các hệ thống có thể hỗ trợ nó; Với phiên bản 1.1 nó là hành vi mặc định). Tính bền bỉ cho phép khách hàng tiếp tục sử dụng kết nối TCP hiện tại sau khi yêu cầu ban đầu của nó đã được hoàn thành. Khách hàng đơn giản đưa ta một yêu cầu mới trên cùng một kết nối. Hình 2.4 cho thấy hành vi này đang hoạt động.

<img src="http://sv1.upsieutoc.com/2017/06/01/12123.png">

Hình 2.3 Các trang web phực tạp như trang này chứ nhiều vật thể, mỗi loại yêu cầu thông điệp HTTP riêng trao đổi để lấy. Trong ví dụ này, trang chính là một đối tượng, và mỗi yếu tố đồ hoạ cá nhân là một đối tượng riêng biệt. Tổng cộng, khách hàng phải phát hành 20 yêu cầu HTTP riêng trước khi nó có thể hiển thị trang.

<img src="http://sv1.upsieutoc.com/2017/06/01/1212123123123.png">

Hình 2.4 Với kết nối liên tục, khách hàng có thể phát hành nhiều yêu cầu HTTP qua kết nối TCP. Người đầu tiên yêu cầu là bước 4, mà câu trả lời máy chủ trong bước 5. Trong bước 6 khách hàng tiếp tục bằng cách gửi máy chủ một yêu cầu trên cùng một TCP kết nối. Máy chủ phản hồi yêu cầu này trong bước 7 và sau đó đóng lại kết nối TCP.

Tính bền bỉ đòi hỏi sự hợp tác từ cả khách hàng và máy chủ. Khách hàng rõ ràng phải đưa ra quyết định sử dụng kết nối liên tục. Nó có thể là như vậy, tuy nhiên chỉ khi máy chủ cho phép nó. Máy chủ không được đóng kết nối TCP sau khi hoàn thành yêu cầu ban đầu của khách hàng.

## 2.1.4 Pipelining (xử lý đường ống)

Tính bền bỉ cho phén một tính năng HTTP cải thiện mỗi định hình pipelining. Với pipelining, một khách hàng không phải chờ phản ứng trược một yêu cầu khi ban hành hành một yêu cầu mới về kết nối. Nó có thể là theo yêu cầu đầu tiên ngay lập tức với yêu cầu thứ hai. Hình 2.5 cho thấy một khách hàng có thể sử dụng pipelining đẻ gửi yêu cầu mà không cần đợi phản hồi. Biểu đồ trong hình 2.6 so sánh hiệu suất của pipelining, sự kiên trì, và các kết nối tiếp đơn. Các con số cho thấy thời gian hiển thị một trang web bao gồm số đối tượng. Biểu đồ giả định rằng một số đối tượng. Biểu đồ giả định rằng sự chậm trể 50 ms tách trình duyệt mà máy chủ, và rằng trình duyệt  kết nối sử dụng modem quay số 56 Kbit/s . Như hình indicates, các cải tiến HTTP 1.1 giới thiệu có thể làm cho một sự khác biệt đáng kể về hiệu suất.

<img src="http://sv1.upsieutoc.com/2017/06/01/dadsdasd.png">

Hình 2.5 Pipelining cho phép một khách hàng HTTP vấn đề yêu cầu mới mà không cần đợi phản hồi từ trước tin nhắn. Trong hình, khách hàng gửi yêu cầu đầu tiên của mình trong 4 bước. Nó ngay sau đó với một yêu cầu thứ hai trong bước 5. Khách hàng không chờ đợi máy chủ đáp ứng, đến bước 6.

<img src="http://sv1.upsieutoc.com/2017/06/01/hungle.png">

Hình 2.6 Kiên trì và sắp xếp đường ống có thể đưa ra những cải tiến đáng kể hiệu suất HTTP, đặc biệt cho các trang Web phức tạp với nhiều các đối tượng. Như biểu đồ cho thấy, một trang web với 20 đối tượng (không điển hình) có thể mất khoảng 4s khi khách hàng dùng serial kết nối. Sự kiên trì cà pipelining với nhau có thể làm giảm thời gian đến dưới 1s.

## 2.2 User Operation (Hoạt động của người dùng)

Giao thức HTTP xác định bốn thao tác cơ bản-GET,POST và DELETE,PUT. Chúng tôi coi đây là hoạt động của người dùng bởi vì, ít nhất trong ngữ cảnh của trình duyệt web, chúng là mỗi kết quả trực tiếp của hành động người dùng. Như chúng ta sẽ thấy trong phần sau , hành động của người dùng có thể gây ra các cuộc trao đổi HTTP khác và nó không có một người dùng cuối để bắt đầu những cuộc trao đổi đó. Tuy nhiên, bốn hoạt động của phần này vẫn còn là hoạt động HTTP cơ bản nhất.

## 2.2.1 Web page retrieval-GET

Các hoạt động HTTP đơn giản nhất của tất cả là GET. Đó là cách khách hàng lấy ra một đối tượng từ máy chủ. Trên web, trình duyệt yêu cầu một trang từ một máy chủ web với một GET. Ví dụ, nhấp vào liên kết ở giũa hình 2.7 sẽ buộc trình duyệt để phát hành yêu cầu GET tới máy chủ yêu cầu trang web mới để hiển thị. Như hình 2.8 cho thấy GET là một trao đổi hai tin nhắn đơn giản máy khách khởi tạo nó bằng cách gửi một thông điệp GET tới máy chủ. Thông báo xác định đối tượng mà khách hàng đang yêu cầu với một bộ nhận dạng tài nguyên thống nhất (URI). Nếu máy chủ có thể trả lại đối tượng yêu cầu, nó sẽ làm như vậy trong phản ứng. Như hình vẽ, máy chủ cho biết thành công với một tình trạng thích hợp; 200 OK là mã trạng thái của một phản ứng thành công. Cùng với mã trạng thái, máy chủ bao gồm các đối tượng chính nó trong phản ứng của nó. Nếu máy chủ không thể trả về đối tượng yêu cầu , sau đó nó có thể trả về bất kỳ mã trạng thái khác. Phần 3.3 chi tiết tất cả các mã trạng thái định nghĩa HTTP.

<img src="http://sv1.upsieutoc.com/2017/06/02/12121212312.png">

Hình 2.7 Sau một liên kết đơn giản trên Web trang làm cho trình duyệt gửi một yêu cầu GET cho trang mới máy chủ. Trong ví dụ này, nhấp chuột trên liên kết "Máy vi tính " sẽ khiến trình duyệt phát hành GET yêu cầu một trang mới.

## 2.2.2 Biểu mẩu web -POST

Mặc dù trình duyệt web chủ yếu bắt đầu như là một cách để xem các trang thông tin, nó đã sớm phát triển bao gồm hai chiều sự tương tác. Trong khi GET cho phép một máy chủ gửi thông tin đến một người dùng, hoạt động của POST cung cấp một cách để khách hàng gửi thông tin đến các máy chủ. Các trình duyệt web thường sử dụng nhất các thao tác POST để gửi biểu mẩu đến các máy chủ web. Hình 2.9 cho thấy ví dụ về hình thức như vậy. Đó là một trang web mà cho phép người sử dụng tìm kiếm các tiêu chuẩn Internet. Khi người dùng nhấp vào nút "cơ sở dữ liệu tìm kiếm", trình duyệt web gửi một yêu cầu POST đến  máy chủ; yêu cầu bao gồm thông tin người dùng đã cung cấp trong biểu mẫu.

<img src="http://sv1.upsieutoc.com/2017/06/02/13c210.png">

Hình 2.8 Một máy chủ đáp ứng yêu cầu GET bằng trả về tài nguyên yêu cầ, thường là một trang web mới. Trang web mới là dữ liệu phản ứng.

<img src="http://sv1.upsieutoc.com/2017/06/02/2f1edc.png">

Hình 2.9 Nộp mẫu web thường có trình duyệt gửi yêu cầu POST tới máy chủ. Thông báo POST bao gồm dữ liệu của biểu mẫu. Trong ví dụ này, dữ liệu POST sẽ bao gồm cụm từ tìm kiếm ("HTTP"), phạm vi (tất cả các trường), kết quả trên mỗi trang (25) và liên kết phương pháp (FTP).

<img src="http://sv1.upsieutoc.com/2017/06/02/34a0fa.png">

Hình 2.10 Máy chủ đáp ứng yêu cầu POST bằng cách trả lại thông tin mới như kết quả tìm kiếm. Thông tin này là mang theo dữ liệu trong phần cứng.

Như hình 2.10 cho thấy, hoạt động POST gần như đơn giản như GET. Khách hàng gửi một thông báo POST và bao gồm thông tin nó muốn gửi đến máy chủ. Giống như GET message một phần của thư POST là một tài nguyên thống nhất mã nhận dạng (URI). Trong trường hợp này, URI xác định đối tượng trên máy chủ có thể xủ lý các thông tin bao gồm. Trên máy chủ web, URI này thường là một chương trình hoặc là một kịch bản. Cũng như với các hoạt động GET, một máy chủ có thể trở lại thông tin tự coi mình là một phần của phản ứng. Để duyệt web thông tin thường là một trang web mới để hiển thị, thường là một trang trang thừa nhận đầu vào của người dùng; trong trường hợp tìm kiếm. Trang web mới này thường hiển thị kết quả tìm kiếm.

## 2.2.3 File upload-PUT

Các hoạt động PUT cũng cung cấp một cách để khách hàng gửi thông tin đến các máy chủ. Nó khác biệt đáng kể so với POST hoạt động, mặc dù như hình 2.11 cho thấy hai trông rất giống nhau. Như với một POST, khách hàng gửi một method. Một URI, và dữ liệu. Máy chủ trả về một mã trạng thái và tuỳ chọn đồng minh dữ liệu. Sự khác biệt giữa POST và PUT là làm thế nào các máy chủ diễn giải định danh tài nguyên thống nhất. Với POST, URI các định một đối tượng trên máy chủ có thể xử lý bao gồm dữ liệu. Với một PUT, mặt khác URI định danh một đối tượng trong đó máy chủ nên đặt dữ liệu. Mặc dù POST URI thường chỉ một chương trình hoặc kịch bản, PUT URI thường là đường dẫn và tên của một tệp. Hình 2.12 cho thấy một ví dụ về hoạt động PUT đang hoạt động. Trên trang mày người sử dụng dụng đã xác định một tập tin cục bộ. Bằng cách nhấp vào nút tải lên, người sử dụng yêu cầu trình duyệt gửi PUT yêu cầu nhiệm vụ đến máy chủ.

<img src="http://sv1.upsieutoc.com/2017/06/02/4b36c5.png">

Hình 2.11 khách hàng có thể sử dụng yêu cầu PUT để gửi một đối tượng mới đến máy chủ. URI đó là một phần yêu cầu cho Server nơi đặt đối tượng.

<img src="http://sv1.upsieutoc.com/2017/06/02/5e22dd.png">

Hình 2.12 Yêu cầu PUT có thể được sử dụng để tải tệp lên máy chủ. Trong đều này ví dụ người dùng muốn lưu trữ chỉ định tệp tin máy chủ.

## 2.1.4 Xoá tệp -DELETE

Với các thao tác GET và PUT, HTTP trở thành một dịch vụ giao thức để truyền tệp đơn giản. Thao tác DELETE hoàn thành chức năng này bằng cách cho khách hàng một cách để xoá bỏ object từ các máy chủ. Trao đổi thư không chứa prises. Như hình 2.13 cho thấy, khách hàng gửi một DELETE tin nhắn cùng với URI của đối tượng máy chủ trên tẩy. Máy chủ đáp ứng với một mã trạng thái và tuỳ chọn. Đồng minh, nhiều dữ liệu hơn cho khách hàng.

<img src="http://sv1.upsieutoc.com/2017/06/02/6e8de1.png">

Hình 2.13 Thao tác DELETE cho phép một máy khách loại bỏ các URI xác định đối tượng để xoá.

## 2.3 Behind the Scenes (đằng sau những cảnh)

Các hoạt động HTTP cơ bản thường xảy ra như là một kết quả trực tiếp hành động của một người dùng cuối. Bốn hoạt động này không phải là chỉ những người mà giao thức định nghĩa, tuy nhiên. Ba vở opera bổ xung các lựa chọn, HEAD, TRACE, thường diễn ra là sau các cảnh quay. Khách hàng sử dụng chúng để liên lạc với máy chủ không phải là quá nhiều để thực hiện hành động người dùng mà là để chuẩn bị cho hay chuẩn đoán các vấn đề với các hoạt động cơ bản. Mặc dù dù phần này không thảo luận thêm về nó, nhưng HTTP đặc điểm kỹ thuật cũng dự trữ tên cho một hoạt động khác, CONNECT. Tiêu chuẩn không xác định bằng cách CONNECT hoạt động. Ngoại trừ để chi ra rằng nó được dự định để hổ trợ đường hầm. Các mở rộng để HTTP có thể định nghĩa CONNECT chi tiết hơn.

## 2.3.1 Khả năng- Options

Khách hàng có thể sử dụng thông điệp Options để khám phá những gì khả năng một máy chủ hỗ trợ. Trao đổi là tiêu chuẩn lại nhiện vụ đáp ứng, như hình mih hoạ 2.14 nếu khách hàng bao gồm URI, máy chủ đáp ứng với các tuỳ chọn có liên quan đối tượng đó. Nếu khách hàng gửi một dấu sao như URI máy chủ trả về các tuỳ chọn chung áp dụng cho tất cả các đối tượng nó duy trì. Một khách hàng có thể sử dụng thông điệp Options để xác định phiên bản HTTP mà máy chủ hổ trợ hoặc trong trường hợp của một cụ thể URI, mà các phương pháp mã hoá máy chủ có thể cung cấp cho đối tượng. Thông tin như vậy sẽ cho phép khách hàng điều chỉnh nó tương tác với máy chử như thế nào hoặc nó thực sự yêu cầu một đối tượng cụ thể.

<img src="http://sv1.upsieutoc.com/2017/06/02/77be51.png">

Hình 2.14 Khách hàng có thể sử dụng một yêu cầu Options hỏi về một đối tượng cụ thể hoặc về máy chủ chính nó. Máy chủ trả về dữ liệu tuỳ chọn trong phản ứng của nó.

## 2.3.2 Status -HEAD

Hoạt động HEAD giống như hoạt động của GET, ngoại trừ máy chủ không trả lại các đối tượng thực tế yêu cầu. Như hình 2.15 cho thấy, máy chủ trả về một mã trạng thái nhưng không có dữ liệu (HEAD là viết tắt cải "HEADER" , khi máy chủ trả về thông báo duy nhất tiêu đề đáp ứng). Khách hàng có thể sử dụng một tin nhắn HEAD khi họ muốn  xác minh rằng một đối tượng tồn tại nhưng họ không cần để thực sự lấy lại đối tượng. Các chương trình xác minh liên kết trong. Ví dụ: các trang web có thể sử dụng thông điệp HEAD để đảm bảo rằng một liên kết đề cập đến một đối tượng hợp lệ mà không tiêu tốn băng thông mạng và các tài nguyên máy chủ mà không truy xuất đầy đủ sẽ yêu cầu. Máy chủ Cache cũng có thể sử dụng các hoạt động HEAD; nó cho họ một cách để xem nếu một đối tượng đã thay đổi mà không thực sự lấy ra ra các đối tượng đầy đủ.


## Path-TRACE 

Thông báo TRACE cung cấp cho khách hàng một cách để kiểm tra mạng đường dẫn đến một máy chủ. Khi máy chủ nhận được TRACE, nó phản hồi bằng cách sao chép thông điệp TRACE và dự liệu phản hồi. Hình 2.16 chỉ ra trường hợp đơn giản nhất. Các thư TRACE messages hữu ích hơn khi nhiều máy chủ tham gia vào việc đáp ứng yêu cầu. Một máy chủ trung gian. Ví dụ có thể chấp nhận yêu cầu từ khách hàng nhưng lại xung quanh và chuyển tiếp các yêu cầu đó lên các máy chủ bổ sung.(Các proxy và máy chủ lưu trữ cache, được mô tả trong phẩn tiếp theo, ví dụ của các máy chủ trung gian như vậy). Khi một server trung gian, TRACE hoạt động như trong hình 2.17. Các máy chủ trung gian sửa đổi yêu cầu bằng cách chèn một đường trong tin nhắn. Tuỳ chọn Via này là một phần của thông báo đến máy chủ đích, và nó được sao chép vào dữ liệu phản hồi của máy chủ. Khi khách hàng nhận được phản hồi, nó có thể thấy các tuỳ chọn Via trong dữ liệu và xác định bất kỳ máy chủ trong trung gian nào trong đường dẫn. Phần 3.2.34 mô tả quá trình này chi tiết hơn.

<img src="http://sv1.upsieutoc.com/2017/06/02/89238e.png">

Hình 2.16 Máy chủ đáp lại yêu cầu của TRACE lặp lại yêu cầu trong thư trả lời của họ.

## Cooperating servers (Máy chủ hợp tác)

Ngoại trừ TRACE message, chương này đã có tập trung nhiều vào giao tiếp giưa một máy khách và một máy chủ duy nhất. Giao thức HTTP định nghĩa phức tạp hơn tương tác, tuy nhiên, thường xuyên liên quan đến nhiều máy chủ hợp tác thay mặt cho khách hàng. Trong phần này chúng ta sẽ xem xét các cách khách nhau mà máy chủ có thể tha gia vào một trao đổi thông tin.

<img src="http://sv1.upsieutoc.com/2017/06/02/95f6ca.png">

Hình 2.17 Yêu cầu TRACE cho phép khách hàng khám phá đường dẫn thông điệp của họ theo dõi qua mạng lưới máy chủ trung gian.

##  2.4.1 Virtual Hosts (máy chủ ảo)

Trong tất cả các cải tiến mà phiên bản HTTP 1.1 thêm vào phiên bản 1.0 một trong số ít nhất là hỗ trợ trực tiếp cho máy chủ ảo. Nhưng mặc dù sự thay đổi giao thức là nhỏ, tính năng này là một lợi ích cho world wide web. Hỗ trợ máy chủ ảo đề cập tới một phần tử quan trọng của kiến trúc web mà nhà thiết kế của phiên bản 1.0 đã không dự đoán- web hoting nhà cung cấp. Sự phổ biến của Internet đã tạo ra cho các trang web, như các tổ chức khác nhau từ các cá nhân . Thiết lập một sự hiện diện trên trang web. Trong nhiều trường hợp, tuy nhiên nó là không thực tế hoặc không hiệu quả cho chính tổ chứ sở hửu và vận hành server, và cơ sở hạ tâng mạng mà trang web yêu cầu. Để gặp nhu cầu này, các nhà cung cấp dịch vụ Internet truyền thống , các hãng truyền thông, cà các nhà cung cấp dịch vụ chuyên biệt có thể luu trữ các trang web thay mặt cho các tổ chức khác. Một dấu hiệu hầu hết các trang web đáng tin cậy trên Internet đểu khiêm tốn và lại quire ít tài nguyên từ các hệ thốn mà họ chạy. Bởi vì họ không yêu cầu một máy chủ chuyên dụng, ví dụ, hầu hết các nhà cung cấp dịch vụ lưu trữ web thực  sự chạy nhiều web riêng biệt các trang web trên trên một máy chủ duy nhất, như thể minh trong hình 2.18 vấn đề đối mặt với một mấy chủ web lưu trữ nhiều trang web đơn giản chỉ ra: Khi khách hàng yêu cầu một trang web, làm thế nào máy chu có biết trang web nào mà khách hàng có gắng truy cập? Xem xét một yêu cầu khách hang cho trang web tương ứng liên quan đến http://wwww.company1.com/news.html. Các người dùng đầu tiên phải giải quyết phần host, wwww.company1.com, với một IP địa chỉ nhà. Sau đó như hình 2.19 cho thấy nó thiết lập một TCP Nection và gửi lệnh HTTP GET news.html tới địa chỉ đó. Lưu ý, tuy nhiên, rằng máy chủ web không tham gia vào độ phân giải DNS, vì vậy nó không biết chủ khách hàng có ý định liên lạc. Máy chủ web không có cách để biết liệu "news.html" có đề cập đến company1.com hoặc company2.com. Trước HTT 1.1 các nhà cung cấp dịch vụ lưu trữ web chỉ có hai cách để giải quyết vấn đề này. Họ có thể yêu cầu các trang web sử dụng duy nhất URIS cho tất cả các trang của họ. Vì vậy, nếu company1.com có trang có treeb news.html trên trang web của công ty, company2.com không thể sử dụng cùng teentrang các trang đó. Trong thực tế, máy chủ lưu trữ web các nhà cung cấp thực hiện giải pháp bằng cách yêu cầu một trang web nhận dạng trong tất cả các tên đường dẫn. Ví dụ, thay vì thẳng thắn URI "http://www.company1.com/news.html" tran web có thể sử dụng "http://www.company1.com/company1.com/news.html" phức tạp hơn. Một lựa chọn khác, các nhà cung cấp dịch vụ lưu trữ web chó thể chỉ định riêng IP địa chủ cho mỗi trang web trên máy chủ của họ. Các máy chủ sau đso xác định trang web nào mà khách hàng yêu cầu bằng cách kiểm tra IP mà khách hàng kết nối. Máy chủ kết thúc với nhiều địa chỉ IP, và địa chỉ IP là nguồn tài nguyên khan hiếm. Với phiên bản 1.1, HTTP giải quyết vấn đề máy chủ ảo với một đơn giản thêm vào yêu cầu của khách hàng. Bổ xung đó là tiêu đề máy chủ, trong đso khách hàng phải đặt máy chủ lưu trữ  tên của trang web mà nó yêu cầu. Như hình 2.20 cho thấy, máy chủ có thể dễ dàng xác định trang web mà một yêu cầu applies, và nó có thể trả lại các nguồn lực thích hợp.

<img src="http://sv1.upsieutoc.com/2017/06/03/11.png">

Hinh 2.18 Lưu trữ ảo cho phép nhiều web địa chỉ chia sẽ cùng một máy chủ web. Cấu hình này là điển hình trong ISP cung cấp web hosting cho nhỏ doanh nghiệp và cá nhân.

<img src="http://sv1.upsieutoc.com/2017/06/03/12.png">

Hình 2.19 Máy ảo có thể làm khó khăn cho máy chủ web để xác định trang web khách hàng đang có gắng truy cập. Trong trường hợp này web vật lý máy chủ không có ý tưởng mà web địa chỉ yêu cầu khách hàng bởi vì nó đã không tham gia vào trao đổi DNS ánh xạ của tên máy chủ đến địa chỉ IP của nó.

## 2.4.2 Redirection (chuyển hướng)

Trong khi hỗ trợ máy chủ ảo cho phép một máy chủ duy nhất hỗ trợ nhiều trang web dễ dàng, chuyển hướng cung cấp một cách để hỗ trợ một trang web duy nhất để sử dụng máy chủ. Chuyển hướng cho phép sử dụng máy chủ  chuyển  hướng khách hàng sang một URI khác cho một đối tượng. Hình 2.21 cho thấy quá trình. Đầu tiên khách hàng yêu cầu một đối tượng từ máy chủ web đầu tiên. Thay vì trả lại object yêu cầu, tuy nhiên, máy chut trả lời với một trạng thái Moved 301 code. Phản ứng cũng chỉ ra một URI mới cho đối tượng. Khách hàng nhận ra URI nà, và trong bước 3, tái phát hành lại nhiệm vụ. Lần này GET thành công, và máy chủ thứ hai lại biển đổi tượng thực sự.

<img src="http://sv1.upsieutoc.com/2017/06/03/1e9d3a.png">

Hình 2.20 Tính năng máy chủ lưu trữ trong phiên bản HTTP 1.1 cho phép khách hàng xác định rõ web họ đang truy cập, vì vậy máy ảo luu trữ web có thể trả lại đúng nội dung.

<img src="http://sv1.upsieutoc.com/2017/06/03/2.png">

Hình 2.21 Một máy chủ chuyển hướng một khách hàng để nói với khách hàng mà đối tượng yêu cầu là nằm ở nơi khách. Khi nào, trong bước 2, khách hàng nhận được 301 Moved đáp ứng, nó sẽ tìm một URI mới trong thông báo phản hồi và đưa ra một thông báo mới yêu cầu GET cho URI đó.

Chyển hướng là điều cần thiết cho môi trường web rất năng động. Nó cung cấp một cách thuận tiện để hỗ trợ sửa đổi trong một trang web, di chuyển nội dung và thậm chí thay đổi cảu một bản sắc công ty. Lưu ý rằng chuyển hướng không phải là chỉ định khác Host. Thường thì trên thực tế, chuyển hướng được sử dụng để thông báo cho client của một đường dẫn mới cho tài nguyên trên cùng một máy chủ. Chú thích có những kỹ thuật khác để hoàn thành hiệu quả tương tự. Máy chủ có thể trả lời bản gốc yêu cầu bằng cách cung cấp một đối tượng Javascript tự động chỉ đạo khách hàng đến một vị trí mới.

## 2.4.3 Proxies, Gateways, and Tnunnels (Proxy, cổng và đường hầm)

Một cách khác nhau mà các máy chủ HTTP có thể hợp tác với nhau khác là bằng cách làm proxy, gateways, hoặc đường hầm. Trong mỗi các vai trò này, máy chủ mà khách hàng đề tiên tiếp xúc các yêu cầu đến một máy chủ mới và sau đó chuyển tiếp các máy chủ thứ hai đáp ứng lại cho khách hàng. Hình 2.22 cho thấy một máy proxy đi vào hoạt động. Trong hình, khách hàng đầu tiên gửi trực tiếp yêu cầu HTTP của nó đến máy chủ Proxy. Máy chủ đó, tuy nhiên không thể trả lời khách hàng ngay lập tức thay vào đó, đưa ra yêu cầu tới một máy chủ thứ hai, mà các nhãn hình.

<img src="http://sv1.upsieutoc.com/2017/06/03/3a0b89.png">

Hình 2.22 Một máy chủ Proxy tự định vị chính nó giữa khách hàng và máy chủ. Nó chuyển tiếp các yêu cầu thay mặt cho khách hàng và chuyển tiếp phản hồi từ các máy chủ.

"Máy chủ gốc". Trong trường hợp cơ bản nhất, thứ hai đã GET một URI tương tự URI; nó chỉ đơn giản là gửi đến một máy chủ. Máy chủ đó xử lý GET thứ hai như thể nó đã đến từ một khách hàng và đáp ứng với các đối tượng yêu cầu. Các máy chủ proxy sau đó có thông tin khách hàng ban đầu yêu cầu và trả về đối tượng đó cho khách hàng trong bước 4. Mặc dù hình 2.22 cho thấy một máy chủ proxy đơn HTTP thấp hơn nhiều proxy để tham gia đáp ứng yêu cầu. Các proxy tạo thành một chuỗi như hình 2.23, đưa ra yêu cầu từ một đến khác cho đến khi đối tượng được yêu cầu có thể được tìm thấy. Các proxy sau đó truyền lại đối tượng đó cho khách hàng theo hướng ngược lại. Khi mỗi máy chủ xử lý một yêu cầu, nó thêm danh tính riêng của mình vào tiêu đề Via trong yêu cầu. Bằng thời gian  yêu cầu đến máy chủ cuối cùng, Via

<img src="http://sv1.upsieutoc.com/2017/06/03/4.png">

Hình 2.23 Máy chủ proxy tạo hoặc cập nhập Via tuỳ chọn khi chúng chuyển tiếp các yêu cầu hoặc phản hồi. Tuỳ chọn này có thể làm cho nó dễ dàng hơn để chuẩn đoán các vấn đề về mạng.

Header sẽ nắm bắt được con đường thực hiện theo yêu cầu thông qua chuỗi máy chủ. Phản ứng tương tụ như nhau qua trình, với mỗi hệ thống trung gian chèn danh tính của nó trong đề Via. Máy chủ proxy thực hiện một số chứ năng quan trọng cho http truyền thông. Phổ biến nhất là hỗ trợ cho trình duyệt, trong phần 2.4.4 thảo luận chi tiết hơn. Sử dụng khác bao gồm việc thực thi chính sách cho một tổ chức. Một công ty có thể chỉ đạo tất cả ác máy khách nội bộ của nó sử dụng một máy proxy để Cess internet công cộng, cho phép các máy chủ proxy để lọc rằng truy cập Internet thích hợp công cộng. Thường thường loại hình này hoạt động là một phần của tường lủa kia. Các máy chủ proxy cũng đã được sử dụng để cung cấp ẩn danh cho các trình duyệt web, ngăn ngừa máy chủ từ phát hiện xác định thông tin về thực tế khách hàng. Nếu như thường thấy, một proxy phụ vụ nhiều máy chủ gốc, sau đó khách hàng thường phải bao gồm các URI tuyệt đối của nó lại nhiệm vụ. Nếu không có URI đầy đủ, proxy có thể không thể cho biết máy chủ nào khách hàng nào muốn liên hệ. Bởi vì điều này hành vi không bình thường đối với nhiều khách hàng và bởi vì khách hàng phải biết gửi yêu cầu của họ đến máy chủ proxy thay vì điểm đến cuối cùng, họ thường phải thường phải được rõ ràng con đã tìm đến để sử dụng Proxy. Chương 5 mô tả một số cơ chế quản trị viên hệ thống có thể sử dụng để tự động cấu hình các máy chủ Proxy cho người dùng của họ. Cổng  và đường hầm hoạt động rất giống các máy chủ proxy. Tuy nhiên, có sự khác biệt tinh tế. Cổng làm việc như một Endpoint đến một chuỗi máy chủ, nhưng họ vẫn dựa vào các máy chủ khác để cung cấp tất cả hoặc một phần của đối tượng yêu cầu. Trong nhiều trường hợp, Gateway sử dụng một giao thức khác với HTTP để truy cập đối tượng. Trong hình 2.24, ví dụ gateway sử dụng Structured truy vấn  để lấy thông tin từ cơ sở dữ liệu hệ thống quản lý.

<img src="http://sv1.upsieutoc.com/2017/06/03/5.png">

Hình 2.24 Một cổng nhận các yêu cầu HTTP và dịch chúng sang một ngôn ngữ khác định dạng như SQL. Cổng cũng đảm bảo rằng bất kỳ thư trả lời nào là đáp ứng yêu cầu HTTP thích hợp.

Trong khi cổng hoạt động như một điểm cuối xác định cho một chuỗi máy chủ đường hầm hoàn toàn ngược lại. Như hình 2.25 chỉ ra, chúng tương đối minh bạch với khách hàng ban đầu; Kháchh hàng có thể thậm chí không nhận thức được rằng một đường hầm tồn tại. Đường hầm cung cấp một dịch vụ, tuy nhiên trong ví dụ của hình 2.25, đường hầm thiết lập một kết nối an toàn với máy chủ thực tế, thêm an ninh để giao tiếp giữa khách hàng và máy chủ. Lưu ý rằng mặc dù HTTP 1.1 xác định hoạt động của đường hầm trong các thuật ngữ chung, như của bài viết này vài thực thực hiện thực tế có sẵn.

## Máy chủ Cache

Máy chủ Cache là một loại máy chủ proxy đặc biệt có chức năng là để cải thiện hiệu suất web. Họ làm điều đó bằng cách nhớ các đối tượng yêu cầu của khách hàng và nếu yêu cùng một đối tượng được yêu cầu một lần nữa, trả lại đối tượng mà họ đã nhớ Bered thay vì yêu cầu nó từ máy chủ nguồn. Các bước 2.26 và 2.27 cho thấy qui trình hình đầu tiên cho thấy hoạt động proxy tiêu chuẩn. Chìa khoá để hoạt động của máy chủ bộ nhớ cache là nó nhớ những yêu cầu đối tượng, nói chung bằng cách luu một bản sao trên đĩa phương của nó hoặc trong ký ức. Hình 2.27 hiển thị hoàn trả cho máy chủ cache. Trong hình này URI một khách hàng mới yêu cầu cùng một đối tượng như hình 2.26. Lần này, tuy nhiên, máy chủ bộ nhớ cache không cần phản con thủ thuật máy chủ nguồn gốc. Nó đơn giản trả về đối tượng đã lưu từ đĩa phương hoặc bộ nhớ của nó. Máy chủ Cache cải thiện hiệu suất web ở cả khách hàng và máy chủ nguồn gốc. Đối với khách hàng, họ rút ngắn tance đến đối tượng khách hàng cần. Nhưn hình 2.26 và 2.27 minh hoạ, một máy chủ bộ nhớ cache có thể được đặt trên cùng một địa phương khu vự như là khách hàng của mình. Các mạng cụ bộ thường có băng thông cao hơn kết nối Internet diện rộng và sự chậm trễ dẫn qua mạng cục bộ nói chung ít hơn nhiều máy chủ cache cũng cải thiện hiệu suất bằng cách giảm tải trên máy chủ gốc. Khi một máy chủ cache trả về một phản đổi khách hàng, đó là một yêu cầu ít hơn để là phiền máy chủ nguồn gốc. Yêu cầu ít hơn có nghĩa là xử lý ít hơn và bộ nhớ lại nguồn gốc mà máy chủ yêu cầu, cũng như băng tần ít hơn chiều rộng cho kết nối internet. Một trong những vấn đề phức tạp hơn đang đối mặt với một máy chủ cache là biết bao lâu các đối tượng nó đã được lưu trữ trong bộ nhớ cache của nó lại chính xác. Với tính chất động của web, một đối tượng rằng máy chủ nguồn gốc đã trả ề tại một thời điểm có thể là siêu ceded dởi một đối tượng mới trong thời gian tới. Khi mà vấn đề, máy chủ bộ nhớ cache không trả lại đối tượng từ cache, nhưng thay vào đó, nó phải truy vấn lại máy chủ nguồn gốc để trieve các đối tượng mới. Như chúng ta sẽ thấy trong phần 3.2, HTTP 1.1 bao gồm một số tiêu đề hỗ trợ các máy chủ bộ nhớ cache. Những tiều đề nói vơi các máy chủ bộ nhớ cache cho dù, một đối tượng có thể được lưu trữ và nếu có, bao lâu nó có thể được cất giữ an toàn. Phần 5.2 kiểm tra hoạt động của máy chủ bộ nhớ cache cụ thể hơn, tập trung những khía cạnh nằm ngoài phạm vi các đặc điểm kỹ thuật HTTP riêng.

<img src="http://sv1.upsieutoc.com/2017/06/03/6.png">

Hình 2.26 Máy chủ Cache là máy chủ proxy yêu cầu chuyển tiếp và phản hồi. Trong bổ xung, họ giử một bản sao địa phương của bất kỳ phản hồi mà họ nhận được.

<img src="http://sv1.upsieutoc.com/2017/06/03/7.png">

Hình 2.27 Khi một khách hàng mới yêu cầu cùng đối tượng, máy chủ bộ nhớ cache trả về bản địa phương thay vì gửi một barnsao khác yêu cầu tất cả các cách để nguồn gốc máy chủ. Điều này tăng tốc đáp ứng, và nó tiết kiệm băng thông cho kết nối internet.

## 2.4.5 Counting and Limiting Page Views 

Bất cứ khi nào một máy chủ bộ nhớ cache trung gian xủa lý lại khách hàng nhiệm vụ, máy chủ nguồn gốc có thể mất một số kiếm soát của nó liên hành động với khách hàng. Trong nhiều cách đso là một lợi ích, như một bộ nhớ cache máy chủ giảm tải trên máy chủ gốc và có thể đáng kể cải thiện hiệu suất của họ. Tuy nhiên có một số nhược điểm. Đối với một số trang web, việc có một bộ nhớ cache cung cấp các trang tới khách hàng là một vấn đề đáng kể vì nó có nghĩa là nguồn gốc máy chủ không biết người dùng thường xuyên xem nội dung của nó như thế nào. Khi trang web thu được doanh thu từ quảng cáo, có thể đếm số lượng người sử dụng trang web có thể là quan trọng cho maximiz doanh thu đó. Do đó, nhiều máy chủ web xác định rõ ràng nội dung của họ mà không thể tiếp cận được, ngay khi bộ nhớ đệm là cả hai có thể và mong muốn. Sự phát triển người opers của HTTP đã nhận ra vấn đề này và giới thiệu một kỹ thuật cho phép bộ nhớ đệm và vẫn cho nguồn gốc máy chủ để đếm và nếu muốn giới hạn lượt xem trang bởi máy khách bộ nhớ cache. Kỹ thuật này là một phần mở rộng cho cơ sở HTTP đặc điểm kỹ thuật; nó được ghi chép trong RFC 2777. Quá trình bắt đầu khi một proxy chèn một tiêu đề vào một thông báo yêu cầu khi nó chuyển tin nhắn trên. Bước 2 và 3 của hình 2.28 hiển thị quá trình này. Bằng cách chèn tiêu đề ở đây, proxy cho thấy sự sẵn sàng báo cáo và giới hạn số lượng lần nó trả về kết quả trả lời từ bộ nhớ cache của nó. Máy chủ gốc đáp ứng lời mời này bằng cách bao gồm một tiêu đề trong phản ứng của nó. Tiêu đề này cho biết các proxy làm thể nào để xử lý các đối tượng liên quan đến báo cáo và sử dụng hạn chế. Sau đó, khi một khách hàng yêu cầu cung một đối tượng thì proxy có bản sao lưu trong bộ nhớ cache sẽ cần xác thực rằng sao chép với máy chủ nguồn. Khi họ là, như hình 2.29 cho thấy, họ đã cập nhập các tiêu đề meter trong yêu cầu của họ. Điều này thông tin là một báo cáo về số lần lục lưu trữ đã được cung cấp cho khách hàng.

<img src="http://sv1.upsieutoc.com/2017/06/04/1.png">

Hình 2.28 Proxy hỗ trợ đo chèn tiêu đề meter trong yêu cầu đi qua chúng. Máy chủ yêu cầu để đo lường trên một đối tượng cụ thể bằng cách bao gồm các tiêu đề meter tỏn tra lời của họ.

## 2.5 Cookie và bảo trì nhà nước

Giao thức HTTP thường hoạt động như thể mỗi máy khách yêu cầu là độc lập với tất cả những người khác. Máy chủ phản hồi bất kỳ yêu cầu nào nghiêm túc về sự thành công của yêu cầu đó, không có sự đề cập đến các yêu cầu khác từ khách hàng. Kiểu hoạt động này được gọi là không quốc tịch vì máy chủ không phải theo dõi trạng thái của khách hàng. Bởi vid duy trì trạng thái đòi hỏi tài nguyển máy chủ hoạt động stateless thường được mong muốn. Tuy nhiên, trong một số ứng dụng, máy chủ cần giữ một số thông tin về mỗi khách hàng. Người dùng thành công đăng nhập vào một trang web, ví dụ, không nên có để đăng nhập lại bất cứ khi nào họ xem một trang khác trên đó. Máy chủ có thể tránh sự bất tiện này bằng cách theo dõi trạng thái của khách hàng. Lần đầu tiên khách hàng yêu cầu một trang từ trang web, máy chủ yêu cầu người dùng đăng nhập. Người dùng tiếp tục duyệt qua trang web và tạo thêm HTTP yêu cầu, tuy nhiên, máy chủ nhớ lại các đăng nhập thành công trước đó và kiềm chế yêu cầu đăng nhập bổ xung.

<img src="http://sv1.upsieutoc.com/2017/06/04/2cda3f.png">

Hình 2.29 Proxy được đo một đối tượng báo cáo kết quả của họ khi họ gởi máy chủ nguồn gốc một yêu cầu mới liên quan đến vật thể. Trong điều này ví dụ proxy B phát hành HEAD yêu cầu đảm bảo lưu trữ bản sao vẫn hợp lệ. Nó bao gồm một Meter tiêu đề trong yêu cầu.

## 2.5.1 Cookie

Bảo trì nhà nước đòi hỏi một khả năng quan trọng: Máy chủ phải có thể kết hợp một yêu cầu HTTP với một yêu cầu khác. Máy chủ phản có thể cho biết, ví dụ, rằng người dùng yêu cầu một trang mới thực sự là cung một người đã đăng nhập, không phải là người dùng khác chưa được uỷ quyền. Cơ chế mà HTTP định nghĩa để bảo trì trạng thái được biết đến như một Cookie đó cho khách hàng trong phản ứng của nó. Một khi khách hàng nhận được một cookie, nó có thể bao gồm các cookia trong các yêu cầu tiếp theo đến cùng một máy chủ, như hình 2.30 chỉ ra. Khách hàng có thể tiếp tục bao gồm các cookie trong các yêu cầu tiếp theo đến cùng một máy chủ. Như hình 2.30 chỉ ra. Khách hàng có thể tiếp tục bao gồm Cookie trong các yêu cầu của nó cho đến khi (a) cookie hết hạn hoặc (B) máy chủ chỉ đạo khách hàng ngừng sử dụng Cookie. Không phải tất cả người dùng web như thực tế là HTTP hỗ trợ  Cookie. Nhiều người dùng xem bảo trì nhà nước như là một cuộc xâm lược của họ riên tư. Bảo trì nhà nước theo định nghĩa của nó cho phép các trang web để theo dõi hành vi duyệt web của người dùng của nó. Đã sử dụng một cách thích hợp, tuy nhiên, bảo trì nhà nhà nước sẽ khoogn có khả năng tăng mối quan tâm riêng tư với hầu hết người dùng. Người dùng nhấp vào nút "thanh toán" của giỏ hàng trực tuyến cho kì thi có thể đánh giá cao rằng trang web có thể nhớ các mặt hàng họ đã thêm vào giỏ. Trên thực tế, hầu hết người dùng sẽ mong đợi một trang web để theo dõi thứ tự của họ; một hàm các cookie làm cho các cookie dễ dàng hơn nhiều. Các vấn đề phát sinh khi các trang web sử dụng Cookie để theo dõi người dùng bằng những cách mà họ không chờ đợi. Ví dụ, một đại lý quảng cáo trực tuyến có thể theo dõi một người dùng khi co đin từ một nhà mô giới chứng khoán trực tuyến, đến một môn thể thao trang web hàng hoá, và sau đó để một cộng đông trực tuyến, đều đặn xây dựng một hồ sơ của cô ấy để trình bày cô ấy chặt chẽ hơn quảng cáo nhằm mục tiêu. Không có cookie, loại bài hát này sẽ không thực tế. Lúc đầu có vẽ như các quy tắc HTTP điều chỉnh việc sử dụng Cookie sẽ bảo về người dùng thoát khỏi loại theo dõi này. Sau tất cả, một khách hàng HTTP có thể trả lại một Cookie chủ cho máy chủ ban đầu đã ban hành nó. Nếu nhà mô giới trực tuyến gửi trình duyệt Cookie, làm thế nào có thể các trang web thể thao hàng hoá, mà là trên một máy chủ khác nhau, lấy cookie từ người dùng? Các trick trong trường hợp này là cookie không thuộc về một trong hai máy chủ. Thay và đó, nó sở hữu bởi một máy chủ quảng cáo bên thứ ba có Rangements với cả mô giới. Hình 2.31 cho thấy bước đầu tiên trong qui trình, khi người dùng truy cập tran web của nhà mô giới trực tuyến. Các trang web từ đầu trang web chứa nhiều đối tượng. Một trong những đối tượng đó là lệnh cầm quảng cáo điều hành. Trình duyệt web của người dùng yêu cầu tất cả các đối tượng tạo trang, bao gồm các biểu ngữ. Thực tế là quảng cáo cư trú trên một máy chủ HTTP khác nhau không phải là một vấn đề. Khách hàng chỉ cần gửi yêu cầu GET này rằng máy chủ chèn Cookie của nó. Sau đó, người dùng tìm kiếm đến trang web thể thao như hình 2.32 minh hoạ, trang web này cũng bao gồm một quảng cáo biểu ngữ và quảng cáo đó cũng nằm trên máy chủ của cơ quan quảng cáo. Trình duyệt web vận dụng một cách chính xác một yêu cầu GET của máy chủ đó. Và bởi vì nó cùng là một máy chủ ban đầu cung cấp Cookie, nó bao gồm các Cookie trong yêu cầu đó. Cơ quan quảng cáo bây giờ biết được các trang web mà người dùng truy cập. Lưu ý, tuy nhiên rằng cơ quan quảng cáo chỉ có thể theo dõi thông tin cho các trang web có mà nó chứa mối quan hệ. Nếu người dùng thăm một trang web khác không có trong thoả thuận với các cơ quan quảng cáo. Trang web sẽ không có quảng cáo biểu ngữ và trao đổi Cookie liên quan, cơ quan này sẽ không biêt về chuyến thăm của người dùng đến trang web.

<img src="http://sv1.upsieutoc.com/2017/06/04/34af60.png">

Hình 2.30 Máy chủ có thể trả lại trạng thái quản lý Cookie trong phản hồi. Khách hàng, nếu muốn, bao gồm các Cookie này trong yêu cầu đến cùng một máy chủ.

<img src="http://sv1.upsieutoc.com/2017/06/04/4.png">

Hình 2.31 Một trang web có thể bao gồm các đồi tượng từ nhiều máy chủ và mỗi máy chủ có thể cung cấp Cookie của riêng mình khi trả lại các đối tượng của nó. Trong ví dụ này trang chính là từ máy chủ web 1, nhưng trang bao gồm một đối tượng và máy chủ quảng cáo có thể bao gồm Cookie trong phản ứng của nó.

<img src="http://sv1.upsieutoc.com/2017/06/04/5.png">

Hình 2.32 Mỗi trang web mới có thể bao gồm các đối tượng từ một máy chủ bên ngoài; các máy chủ có thể truy xuất cookie của nó khi khách hàng yêu cầu những các đối tượng. Trong hình 2 web site cũng có những ncludes một đối tượng từ máy chủ quảng cáo. Ông khách hàng sẽ yêu cầu đối tượng này, và bởi vì nó liên lạc với máy chủ giống như trước, nó có thể trở lại các Cookie của máy chủ trong các yêu cầu đó.

## 2.5.2 Thuộc tính Cookie 

Cookie bao gồm hàng loạt thuộc tính được liệt kê trong bảng 2.1 máy chủ chọn các giá trị cho các thuộc tính được yêu cầu, và nếu nó mong muốn, cho các thuộc tính tuỳ chọn là tốt nhất.

<img src="http://sv1.upsieutoc.com/2017/06/04/652b9f.png">

<img src="http://sv1.upsieutoc.com/2017/06/04/7b1a79.png">

## 2.5.3 Nhận Cookie

Khi một khách hàng nhận được một Cookie, có lưu các thuộc tính đó tạo thành Cookie. Ngoài ra, nếu máy chủ đã bỏ qua bất kỳ thuộc tính tuỳ chọn, khách hàng cung cấp giá trị mặc định. Bảng 2.2 liệt kê các giá trị mặc định mà khách hàng áp dụng cho thiếu thuộc tính.

<img src="http://sv1.upsieutoc.com/2017/06/05/8.png">

Lưu ý rằng khách hàng không bao giờ phải chấp nhận Cookie. Người sử dụng ví dụ có thể cấu hình trình duyệt web của họ để chấp nhận cookie hay không, như hình 2.33 cho thấy. Một máy chủ HTTP, do đó, không thể dựa vào một cookie được chấp nhận, ngay khi người dùng chấp nhận cookie, đặc tả HTTP yêu cầu khách hàng từ chối các cookie theo một số hoàn cảnh. Bỏ qua cookie đơn giản là bỏ qua bởi khách hàng, và do đó, không bao giờ được bao gồm trong nhiệm vụ. Bảng 2.3 liệt kê các điều kiện theo đó khách hàng phải từ chối của máy chủ. Lưu ý rằng khách hàng xem những điều kiện sau khi nó đã áp dụng bất kì giá trị thuộc tính mặc định như được nêu trong bảng 2.2.

<img src="http://sv1.upsieutoc.com/2017/06/05/9.png">

Hình 2.33 Hầu hết trình duyệt cung cấp cho người dùng một số kiểm soát cookie và nhà nước sự quản lý. Hộp thoại này cho thấy một số lựa chọn xác định liệu trình duyệt có thấp nhận cookie. Các trình duyệt khác phân biệt giữa cookie liên tục (được lưu trữ trên ổ đĩa của máy tính cá nhân) và cookie tạm thời xoá trình duyệt ngay khi người dùng thoát khỉ ứng dụng.

**Các điều kiện theo đó khách hàng từ chối Cookie**

<ul>
    <li>Giá trị thuộc tính Path không phait là tiền tố của URL trong yêu cầu của khách hàng.</li>
    <li>Giá trị thuộc tính Domain không có dấu chấm bên trong nó (không chỉ ở đầu), trừ khi giá trị là  " .local" </li>
    <li>Máy chủ trả về cookie không thuộc miền được chỉ định bới thuộc tính domain.</li>
    <li>Phần host của thuộc tính domain, nếu có chứa một dấu chấm trong đó.</li>
    <li>Port của yêu cầu của khách hàng không được bao gồm trong thuộc tính port (trừ khi thuộc tính port vắng mặt)</li>
</ul>

Cuối cùng, khi một khách hàng chấp nhận một cookie mới siêu áp dụng bất kỳ cookie nào được chấp nhận trước đó có xùng NAME, Domain và Path.

## 2.5.4 Returning Cookies

Một khi khách hàng đã chấp nhận một cookie và cung cấp những thông tin thích hợp các giá trị, nó sẽ xác định khi nào để trả lại cookie cho một server trong các yêu cầu HTTP tiếp theo. Bảng 2.4 phác thảo các quy tắc theo một khách hàng bao gồm một cookie trong một yêu cầu. Lưu ý rằng nhiều cookie có thể đáp ứng các tiêu chí của bảng. Trong trường hợp khách hàng nên bao gồm nhiều cookie trong yêu cầu của nó.

**Điều kiện theo đó khách hàng trả lại Cookie**

<ul>
    <li>Tên miền cho yêu cầu mới buộc phải thuộc tên miền được xác định bởi thuộc tính domain của cookie.</li>
    <li>Port yêu cầu mới phải được đưa và danh sách các cổng thuộc tính Port của cookie, trừ khi thuộc tính port đã vắng mặt trong cookie (chỉ ra tất cả các cổng)</li>
    <li>Đường dẫn cho yều cầu mới phải khớp với thuộc tính đường dẫn của cookie, hoặc đại diện cho một đũa trẻ thuộc tính path</li>
    <li>Cookie không phải đã hết hạn, theo thuộc tính độ tuổi tối đa của nó.</li>
</ul>

Khi khách hàng trả lại cookie cho máy chủ, nó bao gồm domain, path và thuộc tính port nếu thuộc tính đó là có trong cookie gốc. Nó không bao gồm những người ở cổng phẩm nếu họ vắng mặt trong cookie gốc.




<a name="b"></a>
# B.Tổng Kết.

### [Try hard](#0)
